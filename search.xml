<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[mysql故障处理记录1]]></title>
      <url>http://riverdba.github.io/2017/03/30/mysql-troubleshooting01/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>摘要：mysql数据库故障处理记录<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="发现故障"><a href="#发现故障" class="headerlink" title="发现故障"></a>发现故障</h3><p>2017-03-29日晚上20点30突然同时收到2条微信告警：（mysql告警:threads_running超过阀值，os告警：cpu usage超过阀值）<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Type: mysql </div><div class="line">Tags: XXX </div><div class="line">Host: 192.168.XXX.XXX:3306 </div><div class="line">Level: critical </div><div class="line">Item: threads_running </div><div class="line">Value: 314 </div><div class="line">Message: too many threads running </div><div class="line">Type: os </div><div class="line">Tags: XXX </div><div class="line">Host: 192.168.XXX.XXX: </div><div class="line">Level: critical </div><div class="line">Item: cpu_idle </div><div class="line">Value: 39% </div><div class="line">Message: too little cpu idle</div></pre></td></tr></table></figure></p>
<h3 id="处理故障"><a href="#处理故障" class="headerlink" title="处理故障"></a>处理故障</h3><p>第一时间登录数据库查看当前运行的SQL：<br><img src="/2017/03/30/mysql-troubleshooting01/1.png" alt="图1"><br>查看慢查询：<br><img src="/2017/03/30/mysql-troubleshooting01/2.png" alt="图2"><br>发现该SQL就是阻塞的根源！<br>查看当前连接数，发现有800多个并发连接卡住，于是第一时间kill掉这些连接以保证业务正常！kill掉连接后数据库连接数下降到正常范围，同时主机CPU也恢复正常！</p>
<h3 id="分析故障"><a href="#分析故障" class="headerlink" title="分析故障"></a>分析故障</h3><p>通过分析这个SQL语句，发现identifying_code字段上是有索引的，这个where条件匹配到的数据存在大量重复（最多的一个identifying_code有十几W行）：<br><img src="/2017/03/30/mysql-troubleshooting01/3.png" alt="图3"><br>而且这些数据中大部分的delete_flag已经是1了。可见这个SQL每次都是将大部分1改为1，并发量大的时候导致每次都锁很多行最终导致连接阻塞。因此可以优化SQL为如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UPDATE XXX</div><div class="line">    set</div><div class="line">      delete_flag = 1</div><div class="line">    where</div><div class="line">    identifying_code = &apos;1517bfd3f7f4558885a&apos; and delete_flag = 0;</div></pre></td></tr></table></figure></p>
<p>这样每次都只将delete_flag为0的改为1，这个条件过滤后每次符合条件的数据只有1行。就避免了每次update大量数据，减少行锁的发生！</p>
<h3 id="故障总结"><a href="#故障总结" class="headerlink" title="故障总结"></a>故障总结</h3><p>这个属于开发的业务逻辑没考虑完善，同时作为DBA没有结合业务做更细的SQL审核也需要自我检讨。</p>
</the>]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 故障诊断 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解mysql的主从复制]]></title>
      <url>http://riverdba.github.io/2017/03/29/Deep-comprehend-mysql-replication/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>摘要：mysql主从复制原理学习笔记<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h3 id="主从复制的架构"><a href="#主从复制的架构" class="headerlink" title="主从复制的架构"></a>主从复制的架构</h3><p><img src="/2017/03/29/Deep-comprehend-mysql-replication/3.png" alt="图3"></p>
<h3 id="主从复制的过程"><a href="#主从复制的过程" class="headerlink" title="主从复制的过程"></a>主从复制的过程</h3><p>当主库上发生事务提交动作时，会记录到主库的binlog中，然后由主库的dump线程发送日志到从库。从库的IO线程负责接收主库的binlog日志并记录到自己的relay log日志。SQL线程负责读取relay log并将数据写入从库。<br>主库的dump线程：<br><img src="/2017/03/29/Deep-comprehend-mysql-replication/0.png" alt="图0"><br>dump线程时刻的等待binlog的变化，一旦变化就将日志发送给从库。<br>从库的IO线程和SQL线程：<br><img src="/2017/03/29/Deep-comprehend-mysql-replication/1.png" alt="图1"><br>从库的IO线程在时刻等待主库的事件发送过来，如果有的话就接受并写入本地的relay log中。<br>从库的SQL线程在时刻等待relay log的变化，一旦有变化就读取并写入数据库。</p>
<p>在主库上看一个事务：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; show master status \G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">             File: mysql-bin.000952</div><div class="line">         Position: 567035014</div><div class="line">     Binlog_Do_DB: </div><div class="line"> Binlog_Ignore_DB: </div><div class="line">Executed_Gtid_Set: 8ac65959-4cb3-11e5-81af-005056a311e0:1-345390234,</div><div class="line">9bc86bd5-a8a0-11e5-991c-005056a3bf07:4-233053957:233053959-572579981</div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line">ERROR: </div><div class="line">No query specified</div><div class="line"></div><div class="line">mysql&gt; show binlog events in &apos;mysql-bin.000952&apos;;</div><div class="line">| mysql-bin.000952 |    236240 | Query          |       706 |      236317 | BEGIN</div><div class="line">| mysql-bin.000952 |    236317 | Rows_query     |       706 |      236630 | # insert into t_table (task_set_id, user_id, task_set_date,task_terminal,</div><div class="line">      task_set_status, day_tast_id, week_task_id, </div><div class="line">      month_task_id)</div><div class="line">    values (&apos;9edd6ca5ff98443f8981a01dc5eae397&apos;, &apos;37728258&apos;, &apos;2017-03-29&apos;, </div><div class="line">      0,2, &apos;1ecf32416e7711e5ad54005056a3bad5&apos;, &apos;&apos;,</div><div class="line">      &apos;&apos;)                                          </div><div class="line">| mysql-bin.000952 |    236630 | Table_map      |       706 |      236712 | table_id: 82476 (t_db.t_table)  </div><div class="line">| mysql-bin.000952 |    236712 | Write_rows     |       706 |      236839 | table_id: 82476 flags: STMT_END_F              </div><div class="line">| mysql-bin.000952 |    236839 | Xid            |       706 |      236870 | COMMIT /* xid=146158662 */          </div><div class="line">| mysql-bin.000952 |    236870 | Gtid           |       706 |      236918 | SET @@SESSION.GTID_NEXT= &apos;9bc86bd5-a8a0-11e5-991c-005056a3bf07:572102075&apos;</div></pre></td></tr></table></figure></p>
<p>注意该事务COMMIT操作后面的<strong>/* xid=146158662 */</strong> ：这是innodb的内部事务号，用于commit的二阶段提交！<br>单实例mysql（内部XA,需设置innodb_support_xa=on）的commit操作要写2个日志：一个是innodb的redo日志（也就是ib_logfile）是没有归档的，因此会被覆盖掉。另一个是mysql的binlog日志，binlog是不会被覆盖的。<br>开始提交阶段：binlog不提交，redo提交<br>正式提交阶段：binlog提交，如果提交成功，则redo完成！如果提交失败，则redo回滚！</p>
<h3 id="主从复制相关参数"><a href="#主从复制相关参数" class="headerlink" title="主从复制相关参数"></a>主从复制相关参数</h3><p>1、server-id：主从要设置不一样<br>2、read_only：主库设为off，从库设为on<br>3、sql_log_bin：主从都开启<br>4、log_slave_updates：如果要做级联复制(M-S-S)就要开启<br>5、binlog_format：row<br>6、binlog_cache_size：<br>7、max_binlog_size：<br>8、expire_logs_days：binlog保存时间<br>9、binlog-do-db：<br>10、binlog-ignore-db：</p>
<h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><p>半同步复制的作用：可以保证主库将日志先传输到备库，然后再返回给应用事务提交成功。这个功能对网络要求较高，如果要使用的话建议把网络优化好一点，比如机器配置千M网卡且将同一组主从服务器位于同一交换机下。<br>查看源码包中是否支持半同步：<br><img src="/2017/03/29/Deep-comprehend-mysql-replication/2.png" alt="图2"><br>使用方法：主库安装semisync_master.so，从库安装semisync_slave.so然后开启rpl_semi_sync_master_enabled=on即可<br>主库安装：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[root@mongohost2 semisync]# /opt/mysql/bin/mysql</div><div class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</div><div class="line">Your MySQL connection id is 243535</div><div class="line">Server version: 5.6.35-log Source distribution</div><div class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</div><div class="line">Oracle is a registered trademark of Oracle Corporation and/or its</div><div class="line">affiliates. Other names may be trademarks of their respective</div><div class="line">owners.</div><div class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</div><div class="line">mysql&gt; show variables like &apos;%rpl_semi%&apos;;</div><div class="line">Empty set (0.00 sec)</div><div class="line">mysql&gt; install plugin rpl_semi_sync_master soname &apos;semisync_master.so&apos;;</div><div class="line">Query OK, 0 rows affected (0.04 sec)</div><div class="line">mysql&gt; show variables like &apos;%rpl_semi%&apos;;</div><div class="line">+------------------------------------+-------+</div><div class="line">| Variable_name                      | Value |</div><div class="line">+------------------------------------+-------+</div><div class="line">| rpl_semi_sync_master_enabled       | OFF   |</div><div class="line">| rpl_semi_sync_master_timeout       | 10000 |  #默认是10秒，可以自己调整</div><div class="line">| rpl_semi_sync_master_trace_level   | 32    |</div><div class="line">| rpl_semi_sync_master_wait_no_slave | ON    |</div><div class="line">+------------------------------------+-------+</div><div class="line">4 rows in set (0.00 sec)</div><div class="line">mysql&gt; set global rpl_semi_sync_master_enabled=on;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">从库：</div><div class="line">mysql&gt; install plugin rpl_semi_sync_slave soname &apos;semisync_slave.so&apos;;</div><div class="line">Query OK, 0 rows affected (0.04 sec)</div></pre></td></tr></table></figure></p>
<h3 id="主从复制常见问题"><a href="#主从复制常见问题" class="headerlink" title="主从复制常见问题"></a>主从复制常见问题</h3><h4 id="主库挂了，如何判断从库是否同步完成？"><a href="#主库挂了，如何判断从库是否同步完成？" class="headerlink" title="主库挂了，如何判断从库是否同步完成？"></a>主库挂了，如何判断从库是否同步完成？</h4><p>从库执行：show slave status \G;<br>查看IO线程读取到主库的binlog日志文件及位置：<br>              Master_Log_File: mysql-bin.000952<br>          Read_Master_Log_Pos: 637762421<br>查看SQL线程执行的文件及位置：<br>        Relay_Master_Log_File: mysql-bin.000952<br>          Exec_Master_Log_Pos: 637762421<br>比较以上两者是否相等。如果都相等说明同步完成，否则没有完成同步！<br>还可以参考：<br>        Seconds_Behind_Master: 0</p>
<p>如果主库重启了。可以通过show master status查看binlog和位置与从库的binlog文件和位置比较是否一致。</p>
<h4 id="mysql主从库同步错误"><a href="#mysql主从库同步错误" class="headerlink" title="mysql主从库同步错误"></a>mysql主从库同步错误</h4><h5 id="错误号：1062"><a href="#错误号：1062" class="headerlink" title="错误号：1062"></a>错误号：1062</h5><p>主键冲突</p>
<h5 id="错误号：1060"><a href="#错误号：1060" class="headerlink" title="错误号：1060"></a>错误号：1060</h5><p>主从DDL不一致</p>
<h5 id="错误号：1032"><a href="#错误号：1032" class="headerlink" title="错误号：1032"></a>错误号：1032</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1032</div><div class="line">Last_Error: Could not execute Update_rows event on table testdb.table; Can&apos;t find record in &apos;table&apos;, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event&apos;s master log mysql-bin.000252, end_log_pos 441796235</div></pre></td></tr></table></figure>
<p>原因：主从数据不一致<br>解决办法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; set sql_slave_skip_counter=1;</div><div class="line">如果就个别事务可以先跳过事务再手动同步数据。如果数据量大则只能重做备库！</div></pre></td></tr></table></figure></p>
<h5 id="错误号：1756"><a href="#错误号：1756" class="headerlink" title="错误号：1756"></a>错误号：1756</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1756</div><div class="line">Last_Error: ... The slave coordinator and worker threads are stopped, possibly leaving data in inconsistent state. A restart should restore consistency automatically, although using non-transactional storage for data or info tables or DDL queries could lead to problems. In such cases you have to examine your data (see documentation for details).</div></pre></td></tr></table></figure>
<p>原因：不明，可能是BUG，偶尔遇到。<br>解决办法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; stop slave;start slave;</div></pre></td></tr></table></figure></p>
<h5 id="错误号：1837"><a href="#错误号：1837" class="headerlink" title="错误号：1837"></a>错误号：1837</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1837</div><div class="line">Last_Error: Worker 7 failed executing transaction &apos;&apos; at master log mysql-bin.000189, end_log_pos 398170585; Error &apos;When @@SESSION.GTID_NEXT is set to a GTID, you must explicitly set it to a different value after a COMMIT or ROLLBACK. Please check GTID_NEXT variable manual page for detailed explanation. Current @@SESSION.GTID_NEXT is &apos;7d7ebcb4-4cb3-11e5-81ae-005056a35f72:198818971&apos;.&apos; on query. Default database: &apos;testdb&apos;. Query: &apos;INSERT INTO table(unit_id, unit_name, unit_type, book_id, sort) VALUES (&apos;130003002653462007003&apos;, &apos;动：综合表演（火车来了）&apos;, 2, &apos;130003002653462&apos;, &apos;130003002653462007003&apos;)&apos;</div></pre></td></tr></table></figure>
<p>原因：不明，可能是BUG，偶尔遇到。<br>解决办法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; stop slave;start slave;</div><div class="line">如果还不行的话就要重启Mysql实例：service mysqld restart</div></pre></td></tr></table></figure></p>
<h5 id="错误号：1236"><a href="#错误号：1236" class="headerlink" title="错误号：1236"></a>错误号：1236</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_IO_Errno: 1236</div><div class="line">Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: &apos;Client requested master to start replication from position &gt; file size; the first event &apos;mysql-bin.000159&apos; at 647052798, the last event read from &apos;/data/log/mysql/mysql-bin.000159&apos; at 4, the last byte read from &apos;/data/log/mysql/mysql-bin.000159&apos; at 4.&apos;</div></pre></td></tr></table></figure>
<p>解决办法：重新指定开始复制的日志位置</p>
<h5 id="错误号：1594"><a href="#错误号：1594" class="headerlink" title="错误号：1594"></a>错误号：1594</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1594</div><div class="line">Last_Error: Relay log read failure: Could not parse relay log event entry. The possible reasons are: the master&apos;s binary log is corrupted (you can check this by running &apos;mysqlbinlog&apos; on the binary log), the slave&apos;s relay log is corrupted (you can check this by running &apos;mysqlbinlog&apos; on the relay log), a network problem, or a bug in the master&apos;s or slave&apos;s MySQL code. If you want to check the master&apos;s binary log or slave&apos;s relay log, you will be able to know their names by issuing &apos;SHOW SLAVE STATUS&apos; on this slave.</div></pre></td></tr></table></figure>
<h5 id="错误号：1118"><a href="#错误号：1118" class="headerlink" title="错误号：1118"></a>错误号：1118</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1118</div><div class="line">Last_Error: Error &apos;Row size too large (&gt; 8126). Changing some columns to TEXT or BLOB or using ROW_FORMAT=DYNAMIC or ROW_FORMAT=COMPRESSED may help. In current row format, BLOB prefix of 768 bytes is stored inline.&apos; on query. Default database: &apos;testdb&apos;. Query: &apos;update table set content = &apos;&lt;span&gt; &lt;/span&gt; \n&lt;p&gt;\n      &lt;span style=&quot;font-family:宋体;font-size:16px;&quot;&gt;&lt;span&gt;一、创设情境、激发兴趣&lt;/span&gt;&lt;/span&gt; \n&lt;/p&gt;\n&lt;span&gt; &lt;/span&gt;&lt;span style=&quot;font-family:宋体;&quot;&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;1、结合具体生活情境，回顾认识质量单位千克、克、吨，进一步感受&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;千克、&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;克、&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;吨的实际质量。&lt;/span&gt;&lt;/span&gt; \n&lt;p style=&quot;color:#000000;font-family:&amp;quot;Times New Roman&amp;quot;,serif;font-size:10.5pt;font-style:normal;font-weight:normal;&quot;&gt;\n   &lt;sp</div></pre></td></tr></table></figure>
<h5 id="错误号：1755"><a href="#错误号：1755" class="headerlink" title="错误号：1755"></a>错误号：1755</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1755</div><div class="line">Last_Error: Cannot execute the current event group in the parallel mode. Encountered event Update_rows, relay-log name /data/mysql2/log/mysqld-relay-bin.000125, position 354 which prevents execution of this event group in parallel mode. Reason: the event is a part of a group that is unsupported in the parallel execution mode.</div></pre></td></tr></table></figure>
<p>原因：5.6版本开启GTID后，MSS架构级联复制的时候会遇到这个BUG（备机salve线程执行SQL,主键冲突的话会导致自己的binlog异常，此时如果有其他备机以这台备机作为主机，会出现复制异常。）<br>解决办法：slave库注释掉：#slave-parallel-workers=64然后重启mysql</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql主从复制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql查询优化技术之语义优化]]></title>
      <url>http://riverdba.github.io/2017/03/28/Sematic-Optimization-of-mysql/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>摘要：工作中遇到的SQL语义优化案例<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="发现慢SQL"><a href="#发现慢SQL" class="headerlink" title="发现慢SQL"></a>发现慢SQL</h3><p>通过监控慢查询，执行时间在1秒以上的SQL如下：<br><img src="/2017/03/28/Sematic-Optimization-of-mysql/图片1.png" alt="图片1"><br>完整SQL：<br><img src="/2017/03/28/Sematic-Optimization-of-mysql/图片2.png" alt="图片2"><br>查看表结构：<br><img src="/2017/03/28/Sematic-Optimization-of-mysql/图片3.png" alt="图片3"><br>查看执行计划：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">EXPLAIN extended</div><div class="line">SELECT id, content, content_type, receiver_id, TYPE, function_type, function_id,</div><div class="line">read_status, send_time, read_time, STATUS</div><div class="line">FROM</div><div class="line">xxxtable</div><div class="line">WHERE receiver_id = &apos;1667510020&apos;</div><div class="line">AND STATUS = 1</div><div class="line">AND TYPE = 2</div><div class="line">AND send_time &lt; &apos;2017-03-22 08:35:50.553&apos; </div><div class="line">AND DATE_SUB(CURDATE(), INTERVAL 12 MONTH ) &lt;= DATE(send_time) </div><div class="line">ORDER BY send_time DESC LIMIT 1; </div><div class="line">/* select#1 */</div><div class="line">select </div><div class="line">`xxxxdb`.`xxxxtable`.`id` AS `id`,</div><div class="line">`xxxxdb`.`xxxxtable`.`content` AS `content`,</div><div class="line">`xxxxdb`.`xxxxtable`.`content_type` AS `content_type`,</div><div class="line">`xxxxdb`.`xxxxtable`.`receiver_id` AS `receiver_id`,</div><div class="line">`xxxxdb`.`xxxxtable`.`type` AS `TYPE`,</div><div class="line">`xxxxdb`.`xxxxtable`.`function_type` AS `function_type`,</div><div class="line">`xxxxdb`.`xxxxtable`.`function_id` AS `function_id`,</div><div class="line">`xxxxdb`.`xxxxtable`.`read_status` AS `read_status`,</div><div class="line">`xxxxdb`.`xxxxtable`.`send_time` AS `send_time`,</div><div class="line">`xxxxdb`.`xxxxtable`.`read_time` AS `read_time`,</div><div class="line">`xxxxdb`.`xxxxtable`.`status` AS `STATUS` </div><div class="line">from</div><div class="line">`xxxxdb`.`xxxxtable` </div><div class="line">where (</div><div class="line">(</div><div class="line">`xxxxdb`.`xxxxtable`.`type` = 2</div><div class="line">) </div><div class="line">and (</div><div class="line">`xxxxdb`.`xxxxtable`.`status` = 1</div><div class="line">) </div><div class="line">and (</div><div class="line">`xxxxdb`.`xxxxtable`.`receiver_id` = &apos;1667510020&apos;</div><div class="line">) </div><div class="line">and (</div><div class="line">`xxxxdb`.`xxxxtable`.`send_time` &lt; &apos;2017-03-22 08:35:50.553&apos;</div><div class="line">) </div><div class="line">and (</div><div class="line">&lt; cache &gt; ((curdate() - interval 12 month)) &lt;= cast(</div><div class="line">`xxxxdb`.`xxxxtable`.`send_time` as date</div><div class="line">)</div><div class="line">)</div><div class="line">) </div><div class="line">order by `xxxxdb`.`xxxxtable`.`send_time` desc </div><div class="line">limit 1</div></pre></td></tr></table></figure></p>
<h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>从表结构定义上看，已经有receiver_id和send_time的联合索引就没必要单独再需要receiver_id索引了。因此可以先drop掉索引idx_receiverid！</p>
<h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>从SQL语义上看，最关键的是发送时间条件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AND send_time &lt; &apos;2017-03-22 08:35:50.553&apos; </div><div class="line">AND DATE_SUB(CURDATE(), INTERVAL 12 MONTH ) &lt;= DATE(send_time)</div></pre></td></tr></table></figure></p>
<p>初步判断业务需求是要查询发送时间小于当前时间，且发送时间在最近12个月内的数据。<br>Send_time数据库中的时间戳格式是：年月日时分秒毫秒，这里却对send_time字段做了date函数转换，开发者目的是为了和12个月前的年月日格式进行比对。为什么不直接让send_time和12个月前的年月日时分秒毫秒格式进行比对呢？这样不就可以去掉对索引字段做函数了吗。因此，我们可以将这2个条件改写为如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AND send_time &lt; &apos;2017-03-22 08:35:50.553&apos; </div><div class="line">AND send_time &gt;= DATE_SUB(NOW(), INTERVAL 12 MONTH )</div></pre></td></tr></table></figure></p>
<p>优化后的执行计划：<br><img src="/2017/03/28/Sematic-Optimization-of-mysql/图片4.png" alt="图片4"><br>这句SQL在优化前的执行计划中是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">and (</div><div class="line">&lt; cache &gt; ((curdate() - interval 12 month)) &lt;= cast(</div><div class="line">`xxxxdb`.`xxxxtable`.`send_time` as date</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>通过对比可以看到优化后省去了mysql对字段做类型转换的工作，同时可以充分利用该字段的索引。</p>
</the>]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql查询优化技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo's tips]]></title>
      <url>http://riverdba.github.io/2017/03/28/hexo-s-tips/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>摘要：hexo小技巧汇总<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="如何修改新建文章模板"><a href="#如何修改新建文章模板" class="headerlink" title="如何修改新建文章模板"></a>如何修改新建文章模板</h3><p>一般文章都需要添加分类和摘要，我们可以加到模板中。进入到hexo根目录的scaffolds下可以看到三个md文件：draft.md\page.md\post.md<br>在post.md中添加分类和摘要后：<br><img src="/2017/03/28/hexo-s-tips/1.png" alt="图片1"><br>这样新建文章的时候就包含分类和摘要了。</p>
<h3 id="如何在博客中引用本地图片"><a href="#如何在博客中引用本地图片" class="headerlink" title="如何在博客中引用本地图片"></a>如何在博客中引用本地图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">首先修改_config.yml中参数 post_asset_folder:true，这样设置后在新建文章时，Hexo会自动创建一个与文章同名的文件夹用来存放图片</div><div class="line">然后安装插件：npm install https://github.com/CodeFalling/hexo-asset-image --save</div><div class="line">引用图片：将图片放在文章同名的文件夹中，比如图片名称：1.png，在md中书写：![图1](hexo-s-comment/1.png)即可。</div></pre></td></tr></table></figure>
<h3 id="报错日志及解决"><a href="#报错日志及解决" class="headerlink" title="报错日志及解决"></a>报错日志及解决</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1:</div><div class="line">报错原因：根据日志定位到第5行，第1列的内容是：categories:Hexo。分类冒号后面需要加个空格再写内容！</div><div class="line">解决办法：改成categories: Hexo即可！</div></pre></td></tr></table></figure>
</the>]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[实现hexo的评论功能]]></title>
      <url>http://riverdba.github.io/2017/03/27/hexo-s-comment/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文介绍如何在博客中添加评论功能！<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""><br>1、首先需要到<a href="https://disqus.com" target="_blank" rel="external">disqus官网</a>注册账号，然后使用账号登录。<br>2、通过账号登录 disqus后，点击“settings”–&gt;在下拉列表中选择“add disqus to site”如图：<br><img src="/2017/03/27/hexo-s-comment/1.png" alt="图1"><br>3、浏览到该网页最下方选择“get started”如图：<br><img src="/2017/03/27/hexo-s-comment/2.png" alt="图2"><br>4、然后点击“i want to install Disqus on my site”：<br><img src="/2017/03/27/hexo-s-comment/3.png" alt="图3"><br>5、创建站点：<br><img src="/2017/03/27/hexo-s-comment/4.png" alt="图4"><br>6、完成create site后就能看到shortname了：<br><img src="/2017/03/27/hexo-s-comment/5.png" alt="图5"><br>7、选择advanced，在Trusted Domains中添加：github.com,github.io<br><img src="/2017/03/27/hexo-s-comment/6.png" alt="图6"><br>注意：一次只能添加一个域名<br>8、最后将shortname填到hexo主题的配置文件中：D:\src\Git\imdba\themes\yelee_config.yml改成如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">disqus: </div><div class="line">  on: true</div><div class="line">  shortname: xxx</div></pre></td></tr></table></figure></the></p>
<p>重新部署下博客，就可以看到每篇文章后面都有评论功能了。<br>有个前提：要登录disqus账号才可以查看和回复评论！</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> disqus </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql性能调优的关键点]]></title>
      <url>http://riverdba.github.io/2017/03/27/Performance-tuning-key-points-of-mysql/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文记录了一些mysql性能调优相关知识。<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h2 id="服务器参数调优，有哪些关键点？"><a href="#服务器参数调优，有哪些关键点？" class="headerlink" title="服务器参数调优，有哪些关键点？"></a>服务器参数调优，有哪些关键点？</h2><h3 id="操作系统的选择"><a href="#操作系统的选择" class="headerlink" title="操作系统的选择"></a>操作系统的选择</h3><p>建议安装在64bit的linux平台（centos\linux\suse）。</p>
<h3 id="关闭SWAP"><a href="#关闭SWAP" class="headerlink" title="关闭SWAP"></a>关闭SWAP</h3><p>设置vm.swappiness = 10，如果设置为0当内存不足时会导致OOM。</p>
<h3 id="关闭NUMA"><a href="#关闭NUMA" class="headerlink" title="关闭NUMA"></a>关闭NUMA</h3><p>如果是单实例部署，需要关闭NUMA。关闭NUMA有3种方式：BIOS中关闭、OS内核中关闭、启动MYSQL时关闭。</p>
<h3 id="多网卡绑定"><a href="#多网卡绑定" class="headerlink" title="多网卡绑定"></a>多网卡绑定</h3><p>一定要做双网卡绑定。关键网络参数调整：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">net.ipv4.tcp_keepalive_time = 120  #用于减少失效tcp连接占用的资源，加快资源回收的效率</div><div class="line">net.ipv4.tcp_keepalive_intvl = 30  #用于减少失效tcp连接占用的资源，加快资源回收的效率</div><div class="line">net.ipv4.tcp_keepalive_probes = 3  #用于减少失效tcp连接占用的资源，加快资源回收的效率</div><div class="line">net.core.rmem_max = 4194304 #最大socket读buffer（单位：字节数）</div><div class="line">net.core.wmem_max = 4194304 #最大socket写buffer（单位：字节数）</div><div class="line">net.ipv4.tcp_moderate_rcvbuf = 1 #开启recv buffer自动调节机制</div><div class="line">net.ipv4.tcp_wmem = 4096        16384   4194304 #为socket发送缓冲区分配的字节数（依次是最小值、默认值、最大值）</div><div class="line">net.ipv4.tcp_rmem = 4096        87380   4194304 #为socket接受缓冲区分配的字节数（依次是最小值、默认值、最大值）</div></pre></td></tr></table></figure></p>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>建议采用deadline。磁盘调度设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">echo deadline &gt; /sys/block/fioa/queue/schedule</div></pre></td></tr></table></figure></p>
<p>查看设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[root@mysql_42 ~]# cat /sys/block/sda/queue/scheduler </div><div class="line">noop anticipatory deadline [cfq]</div></pre></td></tr></table></figure></p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>推荐选择xfs\ext4，格式化时记得添加noatime,nobarrier参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[root@mysql_42 ~]# mount</div><div class="line">/dev/sda3 on / type ext4 (rw)</div><div class="line">proc on /proc type proc (rw)</div><div class="line">sysfs on /sys type sysfs (rw)</div><div class="line">devpts on /dev/pts type devpts (rw,gid=5,mode=620)</div><div class="line">tmpfs on /dev/shm type tmpfs (rw)</div><div class="line">/dev/sda1 on /boot type ext4 (rw)</div><div class="line">/dev/sdb on /data type ext4 (rw)</div><div class="line">/dev/sdc on /log type ext4 (rw)</div><div class="line">none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)</div></pre></td></tr></table></figure></p>
<h3 id="调大open-files"><a href="#调大open-files" class="headerlink" title="调大open files"></a>调大open files</h3><p>一定要调大open files，可以通过命令：ulimit -n查看。</p>
<h3 id="修改-etc-hosts绑定IP和主机名。"><a href="#修改-etc-hosts绑定IP和主机名。" class="headerlink" title="修改/etc/hosts绑定IP和主机名。"></a>修改/etc/hosts绑定IP和主机名。</h3><h2 id="MySQL性能调优有哪些关键点-经验？"><a href="#MySQL性能调优有哪些关键点-经验？" class="headerlink" title="MySQL性能调优有哪些关键点/经验？"></a>MySQL性能调优有哪些关键点/经验？</h2><h3 id="实例参数调优"><a href="#实例参数调优" class="headerlink" title="实例参数调优"></a>实例参数调优</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">innodb_buffer_pool_size=物理内存的60%-80%  #总IO能力</div><div class="line">innodb_thread_concurrency=CPU的核数  #线程的并发数</div><div class="line">query_cache_type=0  #禁用结果集缓存，一般通过redis\memcache缓存</div><div class="line">query_cache_size=0  #禁用结果集缓存</div><div class="line">max_user_connections=应用连接池大小X应用服务器的数量 #连接数设置要考虑每个会话占用的内存</div><div class="line">interactive_timeout=8小时 #交互连接空闲超时</div><div class="line">wait_timeout=8小时 #非交互的连接空闲超时</div><div class="line">innodb_io_capacity=20000（SSD盘） #innodb每秒后台进程处理IO操作的数据页（page）上限</div><div class="line">innodb_flush_log_at_trx_commit=1 #每次事务提交都刷盘，可保证数据安全。若设置为0的话是每秒刷盘，和提交没关系，不建议。设置为2的话每次提交会把数据存到操作系统的缓存中，然后定期刷盘。如果操作系统挂掉了数据就丢了。5.6以后该参数没有性能问题了。</div><div class="line">sync_binlog=1#1个提交就把日志从缓存写到日志文件</div><div class="line">innodb_log_file_size=1-2G（SAS盘）；4-8G（SSD盘）#日志文件的大小，若设置太小日志文件会频繁切换产生新文件，影响IO能力。</div><div class="line">innodb_log_files_in_group=4-8 #日志组的数量</div><div class="line">innodb_flush_method=O_DIRECT #刷脏块的方式：直接落盘，避免数据多次被cache</div><div class="line">innodb_max_dirty_pages_pct=50 #innodb buffer cache中的脏块刷到磁盘的比例</div><div class="line">innodb_flush_neighbors=0 #合并相邻页数据为1个IO：SAS建议开启，SSD可以关闭</div><div class="line">transaction-isolation = READ-COMMITTED #隔离级别</div></pre></td></tr></table></figure>
<h3 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h3><p>1、制定SQL编写规范，约束开发人员从项目开始阶段就编写出高效的SQL：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、禁止多于3表的join</div><div class="line">2、不要select *</div><div class="line">3、count(*) 尽量用redis缓存去做</div><div class="line">4、避免多作的排序  比如group by 时不用 排序 order by null</div><div class="line">5、模糊查询前缀不用要%  如 like &apos;ss%&apos;</div><div class="line">6、使用in 代替 or</div><div class="line">7、禁止隐式转换</div><div class="line">8、禁止负向查询 如 not in, != ,not like等</div><div class="line">9、尽量用union all 代替  union  ,union 会排序去重</div><div class="line">10、where尽量早过滤</div><div class="line">11、不做计算 如select id*10.2 from t1 </div><div class="line">12、用id条件过滤数据后再分页where id&gt;10000 limit 10，不要用 limit 10000,10</div></pre></td></tr></table></figure></p>
<p>2、实时监控慢查询，通过分析执行计划优化SQL语句<br>3、合理的进行索引设计<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">覆盖索引</div><div class="line">1、查询谓词都能通过index进行扫描</div><div class="line">2、排序谓词都能利用index的有序性</div><div class="line">3、index包含了查询所需要的所有字段，这样只用索引就不用查表了</div><div class="line">不能使用索引</div><div class="line">1、不要给选择率低的字段建索引（通过索引扫描记录超30%就全表扫描了） 如 性别 男和女 直接查表快走索引更慢</div><div class="line">2、联合索引中，第一个索引不要使用范围查询，第一个查询条件不要是最左索引列</div><div class="line">3、like 查询最左 不要是%开始</div><div class="line">4、两个独立索引，一个用于检索，一个用于排序，（索引不是越多越好，尽量合并）</div><div class="line">5、表关联字段类型不一样（长度不一样）不会走索引</div><div class="line">6、索引字段使用函数</div><div class="line">7、不要使用外键约束</div></pre></td></tr></table></figure></p>
<h3 id="架构调优"><a href="#架构调优" class="headerlink" title="架构调优"></a>架构调优</h3><p>实时监控大表，合理制定拆分方案实施分库分表。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql性能调优技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql查询优化技术之连接消除]]></title>
      <url>http://riverdba.github.io/2017/03/22/join-elimination-technique-of-mysql/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文是关于mysql的连接消除技术：外连接消除、连接消除、嵌套连接消除。<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h3 id="连接消除技术包括三种：外连接消除、连接消除、嵌套连接消除"><a href="#连接消除技术包括三种：外连接消除、连接消除、嵌套连接消除" class="headerlink" title="连接消除技术包括三种：外连接消除、连接消除、嵌套连接消除"></a>连接消除技术包括三种：外连接消除、连接消除、嵌套连接消除</h3><p><font color="#0099ff" size="4" face="微软雅黑">1、外连接消除</font><br>外连接消除就是把外连接变为内连接。之所以要消除外连接，是因为查询优化器在处理外连接操作时所消耗的时间多于内连接，因此消除外连接后可以加快查询速度。同时可以减少不必要的I/O开销，加快算法执行速度。<br>创建测试表并插入数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE t_1 (t_1_id INT UNIQUE, t_1_col_1 INT, t_1_col_2 VARCHAR(10));</div><div class="line">CREATE TABLE t_2 (t_2_id INT UNIQUE, t_2_col_1 INT, t_2_col_2 VARCHAR(10));</div><div class="line">INSERT INTO t_1 VALUES (1, 11, &apos;t_1_1&apos;);   INSERT INTO t_1 VALUES (2, 12, NULL);</div><div class="line">INSERT INTO t_1 VALUES (3, NULL, &apos;t_1_3&apos;); INSERT INTO t_1 VALUES (4, 14, &apos;t_1_4&apos;);</div><div class="line">INSERT INTO t_1 VALUES (5, 15, NULL);      INSERT INTO t_1 VALUES (7, NULL, NULL);</div><div class="line">INSERT INTO t_2 VALUES (1, 11, &apos;t_2_1&apos;);   INSERT INTO t_2 VALUES (2, NULL, &apos;t_2_2&apos;);</div><div class="line">INSERT INTO t_2 VALUES (3, 13, NULL);      INSERT INTO t_2 VALUES (4, 14, &apos;t_2_4&apos;);</div><div class="line">INSERT INTO t_2 VALUES (6, 16, &apos;t_2_6&apos;);   INSERT INTO t_2 VALUES (7, NULL, NULL);</div><div class="line">root@testdb 02:21:55&gt;select * from t_1;</div><div class="line">+--------+-----------+-----------+</div><div class="line">| t_1_id | t_1_col_1 | t_1_col_2 |</div><div class="line">+--------+-----------+-----------+</div><div class="line">|      1 |        11 | t_1_1     |</div><div class="line">|      2 |        12 | NULL      |</div><div class="line">|      3 |      NULL | t_1_3     |</div><div class="line">|      4 |        14 | t_1_4     |</div><div class="line">|      5 |        15 | NULL      |</div><div class="line">|      7 |      NULL | NULL      |</div><div class="line">+--------+-----------+-----------+</div><div class="line">6 rows in set (0.00 sec)</div><div class="line">root@testdb 02:22:08&gt;select * from t_2;</div><div class="line">+--------+-----------+-----------+</div><div class="line">| t_2_id | t_2_col_1 | t_2_col_2 |</div><div class="line">+--------+-----------+-----------+</div><div class="line">|      1 |        11 | t_2_1     |</div><div class="line">|      2 |      NULL | t_2_2     |</div><div class="line">|      3 |        13 | NULL      |</div><div class="line">|      4 |        14 | t_2_4     |</div><div class="line">|      6 |        16 | t_2_6     |</div><div class="line">|      7 |      NULL | NULL      |</div><div class="line">+--------+-----------+-----------+</div><div class="line">6 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>语句一：使用TRUE作为ON的子句，WHERE子句包括连接条件且WHERE条件可以保证从结果中排除外连接右侧（右表）生成的值为NULL的行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 02:48:44&gt;SELECT * FROM t_1 LEFT JOIN t_2 ON true WHERE t_1_id = t_2_id;</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">| t_1_id | t_1_col_1 | t_1_col_2 | t_2_id | t_2_col_1 | t_2_col_2 |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">|      1 |        11 | t_1_1     |      1 |        11 | t_2_1     |</div><div class="line">|      2 |        12 | NULL      |      2 |      NULL | t_2_2     |</div><div class="line">|      3 |      NULL | t_1_3     |      3 |        13 | NULL      |</div><div class="line">|      4 |        14 | t_1_4     |      4 |        14 | t_2_4     |</div><div class="line">|      7 |      NULL | NULL      |      7 |      NULL | NULL      |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">5 rows in set (0.00 sec)</div><div class="line">root@testdb 02:22:11&gt;explain extended SELECT * FROM t_1 LEFT JOIN t_2 ON true WHERE t_1_id = t_2_id;show warnings;</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">| id | select_type | table | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">|  1 | SIMPLE      | t_1   | ALL  | t_1_id        | NULL   | NULL    | NULL              |    6 |   100.00 | NULL  |</div><div class="line">|  1 | SIMPLE      | t_2   | ref  | t_2_id        | t_2_id | 5       | testdb.t_1.t_1_id |    1 |   100.00 | NULL  |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                 |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t_1`.`t_1_id` AS `t_1_id`,`testdb`.`t_1`.`t_1_col_1` AS `t_1_col_1`,`testdb`.`t_1`.`t_1_col_2` AS `t_1_col_2`,`testdb`.`t_2`.`t_2_id` AS `t_2_id`,`testdb`.`t_2`.`t_2_col_1` AS `t_2_col_1`,`testdb`.`t_2`.`t_2_col_2` AS `t_2_col_2` from `testdb`.`t_1` join `testdb`.`t_2` where (`testdb`.`t_2`.`t_2_id` = `testdb`.`t_1`.`t_1_id`) |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">从执行计划看到被优化器处理后的语句由left join优化成了join。</div></pre></td></tr></table></figure></p>
<p>语句二：使用ON子句包括连接条件，并不能保证从结果中排除外连接右侧（右表）生成的值为NULL的行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 02:53:25&gt;SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id;</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">| t_1_id | t_1_col_1 | t_1_col_2 | t_2_id | t_2_col_1 | t_2_col_2 |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">|      1 |        11 | t_1_1     |      1 |        11 | t_2_1     |</div><div class="line">|      2 |        12 | NULL      |      2 |      NULL | t_2_2     |</div><div class="line">|      3 |      NULL | t_1_3     |      3 |        13 | NULL      |</div><div class="line">|      4 |        14 | t_1_4     |      4 |        14 | t_2_4     |</div><div class="line">|      5 |        15 | NULL      |   NULL |      NULL | NULL      |</div><div class="line">|      7 |      NULL | NULL      |      7 |      NULL | NULL      |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">6 rows in set (0.01 sec)</div><div class="line">root@testdb 03:06:26&gt;explain extended SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id;show warnings;</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">| id | select_type | table | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">|  1 | SIMPLE      | t_1   | ALL  | NULL          | NULL   | NULL    | NULL              |    6 |   100.00 | NULL  |</div><div class="line">|  1 | SIMPLE      | t_2   | ref  | t_2_id        | t_2_id | 5       | testdb.t_1.t_1_id |    1 |   100.00 | NULL  |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">+-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                            |</div><div class="line">+-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t_1`.`t_1_id` AS `t_1_id`,`testdb`.`t_1`.`t_1_col_1` AS `t_1_col_1`,`testdb`.`t_1`.`t_1_col_2` AS `t_1_col_2`,`testdb`.`t_2`.`t_2_id` AS `t_2_id`,`testdb`.`t_2`.`t_2_col_1` AS `t_2_col_1`,`testdb`.`t_2`.`t_2_col_2` AS `t_2_col_2` from `testdb`.`t_1` left join `testdb`.`t_2` on((`testdb`.`t_1`.`t_1_id` = `testdb`.`t_2`.`t_2_id`)) where 1 |</div><div class="line">+-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">可以看到这个结果集第5行的右侧结果集存在NULL的情况，其执行计划依然是left join，是没办法优化为join的。</div></pre></td></tr></table></figure></p>
<p>语句三：使用ON和WHERE子句包括连接条件,可以保证从结果中排除外连接右侧（右表）生成的值为NULL的行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:06:42&gt;SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id WHERE t_1_id = t_2_id;</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">| t_1_id | t_1_col_1 | t_1_col_2 | t_2_id | t_2_col_1 | t_2_col_2 |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">|      1 |        11 | t_1_1     |      1 |        11 | t_2_1     |</div><div class="line">|      2 |        12 | NULL      |      2 |      NULL | t_2_2     |</div><div class="line">|      3 |      NULL | t_1_3     |      3 |        13 | NULL      |</div><div class="line">|      4 |        14 | t_1_4     |      4 |        14 | t_2_4     |</div><div class="line">|      7 |      NULL | NULL      |      7 |      NULL | NULL      |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">5 rows in set (0.00 sec)</div><div class="line"></div><div class="line">root@testdb 03:11:24&gt;explain extended SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id WHERE t_1_id = t_2_id;</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">| id | select_type | table | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">|  1 | SIMPLE      | t_1   | ALL  | t_1_id        | NULL   | NULL    | NULL              |    6 |   100.00 | NULL  |</div><div class="line">|  1 | SIMPLE      | t_2   | ref  | t_2_id        | t_2_id | 5       | testdb.t_1.t_1_id |    1 |   100.00 | NULL  |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">root@testdb 03:11:38&gt;show warnings;</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                 |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t_1`.`t_1_id` AS `t_1_id`,`testdb`.`t_1`.`t_1_col_1` AS `t_1_col_1`,`testdb`.`t_1`.`t_1_col_2` AS `t_1_col_2`,`testdb`.`t_2`.`t_2_id` AS `t_2_id`,`testdb`.`t_2`.`t_2_col_1` AS `t_2_col_1`,`testdb`.`t_2`.`t_2_col_2` AS `t_2_col_2` from `testdb`.`t_1` join `testdb`.`t_2` where (`testdb`.`t_2`.`t_2_id` = `testdb`.`t_1`.`t_1_id`) |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">可以看到语句三同语句一是一样的，被优化器处理后的语句由left join优化成了join。</div></pre></td></tr></table></figure></p>
<p>语句四：当外表的索引列出现在WHERE子句中，可以看到依然是left join无法被优化。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:11:38&gt;EXPLAIN EXTENDED SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id WHERE t_1_id&gt;0;show warnings;</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">| id | select_type | table | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra       |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">|  1 | SIMPLE      | t_1   | ALL  | t_1_id        | NULL   | NULL    | NULL              |    6 |   100.00 | Using where |</div><div class="line">|  1 | SIMPLE      | t_2   | ref  | t_2_id        | t_2_id | 5       | testdb.t_1.t_1_id |    1 |   100.00 | NULL        |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line">注：左向外连接的结果集包括左表(t_1)所有的行，不仅是连接所匹配的行，还包括左表某行在右表中没有匹配的行用NULL表示。</div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                                                        |</div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t_1`.`t_1_id` AS `t_1_id`,`testdb`.`t_1`.`t_1_col_1` AS `t_1_col_1`,`testdb`.`t_1`.`t_1_col_2` AS `t_1_col_2`,`testdb`.`t_2`.`t_2_id` AS `t_2_id`,`testdb`.`t_2`.`t_2_col_1` AS `t_2_col_1`,`testdb`.`t_2`.`t_2_col_2` AS `t_2_col_2` from `testdb`.`t_1` left join `testdb`.`t_2` on((`testdb`.`t_2`.`t_2_id` = `testdb`.`t_1`.`t_1_id`)) where (`testdb`.`t_1`.`t_1_id` &gt; 0) |</div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>语句五：当内表的索引列出现在WHERE子句中，left join可以被优化join。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:21:22&gt;EXPLAIN EXTENDED SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id WHERE t_2_id&gt;0;show warnings;</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">| id | select_type | table | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra       |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">|  1 | SIMPLE      | t_1   | ALL  | t_1_id        | NULL   | NULL    | NULL              |    6 |   100.00 | Using where |</div><div class="line">|  1 | SIMPLE      | t_2   | ref  | t_2_id        | t_2_id | 5       | testdb.t_1.t_1_id |    1 |   100.00 | NULL        |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                                                     |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t_1`.`t_1_id` AS `t_1_id`,`testdb`.`t_1`.`t_1_col_1` AS `t_1_col_1`,`testdb`.`t_1`.`t_1_col_2` AS `t_1_col_2`,`testdb`.`t_2`.`t_2_id` AS `t_2_id`,`testdb`.`t_2`.`t_2_col_1` AS `t_2_col_1`,`testdb`.`t_2`.`t_2_col_2` AS `t_2_col_2` from `testdb`.`t_1` join `testdb`.`t_2` where ((`testdb`.`t_2`.`t_2_id` = `testdb`.`t_1`.`t_1_id`) and (`testdb`.`t_1`.`t_1_id` &gt; 0)) |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>综上实例可以知道外连接优化的本质：语义上是外连接，但WHER条件使得外连接可以蜕化为内连接</p>
<p><font color="#0099ff" size="4" face="微软雅黑">2、连接消除</font><br>连接消除就是去掉不必要的连接对象，减少连接操作。<br>准备测试数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:44:52&gt;select * from t1 limit 1;</div><div class="line">+----+------+</div><div class="line">| a1 | b1   |</div><div class="line">+----+------+</div><div class="line">|  1 | 1    |</div><div class="line">+----+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">root@testdb 03:45:05&gt;select * from t2 limit 1; </div><div class="line">+----+------+</div><div class="line">| a2 | b2   |</div><div class="line">+----+------+</div><div class="line">|  1 |    1 |</div><div class="line">+----+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">root@testdb 03:45:10&gt;select * from t3 limit 1; </div><div class="line">+----+------+</div><div class="line">| a3 | b3   |</div><div class="line">+----+------+</div><div class="line">|  1 |    1 |</div><div class="line">+----+------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>语句1：唯一键/主键作为连接条件，三表内连接可以去掉中间表（mysql优化器不支持，需人工去掉）<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:47:24&gt;select t1.*,t3.* from t1 join t2 on (a1=a2) join t3 on (a2=a3) limit 1;</div><div class="line">+----+------+----+------+</div><div class="line">| a1 | b1   | a3 | b3   |</div><div class="line">+----+------+----+------+</div><div class="line">|  1 | 1    |  1 |    1 |</div><div class="line">+----+------+----+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">root@testdb 04:04:24&gt;explain extended select t1.*,t3.* from t1 join t2 on (a1=a2) join t3 on (a2=a3) limit 1;show warnings;</div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------+------+----------+-------------+</div><div class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref          | rows | filtered | Extra       |</div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------+------+----------+-------------+</div><div class="line">|  1 | SIMPLE      | t1    | index  | PRIMARY       | idx_b1  | 21      | NULL         | 9977 |   100.00 | Using index |</div><div class="line">|  1 | SIMPLE      | t2    | eq_ref | PRIMARY       | PRIMARY | 4       | testdb.t1.a1 |    1 |   100.00 | Using index |</div><div class="line">|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY | 4       | testdb.t1.a1 |    1 |   100.00 | NULL        |</div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------+------+----------+-------------+</div><div class="line">3 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                            |</div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t1`.`a1` AS `a1`,`testdb`.`t1`.`b1` AS `b1`,`testdb`.`t3`.`a3` AS `a3`,`testdb`.`t3`.`b3` AS `b3` from `testdb`.`t1` join `testdb`.`t2` join `testdb`.`t3` where ((`testdb`.`t2`.`a2` = `testdb`.`t1`.`a1`) and (`testdb`.`t3`.`a3` = `testdb`.`t1`.`a1`)) limit 1 |</div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">可以看到这个语句中的t2表仅仅作为连接条件，查询目标列没有t2的列，它属于多余的对象，但是优化器依然去连接它。</div><div class="line">我们实际工作中可以人工去掉t2表，改写为：</div><div class="line">root@testdb 03:47:40&gt;select t1.*,t3.* from t1 join t3 on (a1=a3) limit 1;</div><div class="line">+----+------+----+------+</div><div class="line">| a1 | b1   | a3 | b3   |</div><div class="line">+----+------+----+------+</div><div class="line">|  1 | 1    |  1 |    1 |</div><div class="line">+----+------+----+------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>语句2：可去除的表，除了作为连接对象外，不出现在任何子句中比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:48:00&gt;select max(b1) from t1,t2;</div><div class="line">+---------+</div><div class="line">| max(b1) |</div><div class="line">+---------+</div><div class="line">| 9999    |</div><div class="line">+---------+</div><div class="line">1 row in set (2.74 sec)</div><div class="line">可以去掉t2：</div><div class="line">root@testdb 03:54:56&gt;select max(b1) from t1;</div><div class="line">+---------+</div><div class="line">| max(b1) |</div><div class="line">+---------+</div><div class="line">| 9999    |</div><div class="line">+---------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">还有select a1 from t1,t2 group by a1可以改为select a1 from t1 group by a1等类似写法</div></pre></td></tr></table></figure></p>
<p><font color="#0099ff" size="4" face="微软雅黑">3、嵌套连接消除</font><br>连接存在多个层次，用括号标识连接的优先次序。嵌套连接消除，就是消除嵌套的连接层次，把多个层次的连接减少为较少层次的连接，尽量“扁平化”。<br>创建测试表及数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE B (b1 INT, b2 VARCHAR(9));</div><div class="line">CREATE TABLE A (a1 INT, a2 VARCHAR(9));</div><div class="line">CREATE TABLE C (c1 INT, c2 VARCHAR(9));</div><div class="line">INSERT INTO B VALUES(1, &apos;B1&apos;), (NULL, &apos;B2&apos;), (31, &apos;B31&apos;), (32, &apos;B32&apos;), (NULL, &apos;B4&apos;),(5, &apos;B5&apos;), (6, &apos;B6&apos;);</div><div class="line">INSERT INTO A VALUES(1, &apos;A1&apos;), (null, &apos;A2&apos;), (NULL, &apos;A31&apos;), (32, &apos;A32&apos;), (4, &apos;A4&apos;), (5, &apos;A5&apos;), (NULL, &apos;A6&apos;);</div><div class="line">INSERT INTO C VALUES(1, &apos;C1&apos;), (NULL, &apos;C2&apos;), (31, &apos;C31&apos;), (NULL, &apos;C32&apos;), (4, &apos;C4&apos;), (NULL, &apos;C5&apos;),(6, &apos;A6&apos;);</div></pre></td></tr></table></figure></p>
<p>语句示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 04:17:29&gt;EXPLAIN EXTENDED SELECT * FROM A JOIN (B JOIN C ON B.b1=C.c1) ON A.a1=B.b1 </div><div class="line">    -&gt; WHERE A.a1 &gt; 1;</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</div><div class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</div><div class="line">|  1 | SIMPLE      | A     | ALL  | NULL          | NULL | NULL    | NULL |    7 |   100.00 | Using where                                        |</div><div class="line">|  1 | SIMPLE      | B     | ALL  | NULL          | NULL | NULL    | NULL |    7 |   100.00 | Using where; Using join buffer (Block Nested Loop) |</div><div class="line">|  1 | SIMPLE      | C     | ALL  | NULL          | NULL | NULL    | NULL |    7 |   100.00 | Using where; Using join buffer (Block Nested Loop) |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</div><div class="line">3 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">root@testdb 04:18:20&gt;show warnings;</div><div class="line">+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                         |</div><div class="line">+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`a`.`a1` AS `a1`,`testdb`.`a`.`a2` AS `a2`,`testdb`.`b`.`b1` AS `b1`,`testdb`.`b`.`b2` AS `b2`,`testdb`.`c`.`c1` AS `c1`,`testdb`.`c`.`c2` AS `c2` from `testdb`.`a` join `testdb`.`b` join `testdb`.`c` where ((`testdb`.`b`.`b1` = `testdb`.`a`.`a1`) and (`testdb`.`c`.`c1` = `testdb`.`a`.`a1`) and (`testdb`.`a`.`a1` &gt; 1)) |</div><div class="line">+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">从该SQL语义上看，是希望先执行B和C连接，然后再和A连接。但是执行计划上看到连接顺序依次是先A和B再和C，说明mysql优化器是支持对嵌套连接的消除的。</div></pre></td></tr></table></figure></p>
<p>针对三种连接技术做个简单的总结：</p>
<ul>
<li>连接消除是去掉被连接的某个对象。</li>
<li>外连接消除是去掉外连接的语义使其变为内连接。</li>
<li>嵌套连接消除是一种连接的语义顺序的变化。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql查询优化技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://riverdba.github.io/2017/03/21/hello-world/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>从这里开始，快速开启博客之旅！<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""><br>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</the></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div><div class="line">简写命令：hexo n <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>新建一篇博文，新建的md文件位于：hexo当前目录/source/_posts中。<br>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo server</div><div class="line">简写命令：hexo s</div></pre></td></tr></table></figure>
<p>这个命令是开启本地hexo服务用的，可以访问<a href="http://localhost:4000/进行本地预览。" target="_blank" rel="external">http://localhost:4000/进行本地预览。</a><br>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div><div class="line">简写命令：hexo g</div></pre></td></tr></table></figure>
<p>一般部署上去的时候都需要编译一下，编译后，会出现一个 public 件夹，将所有的md文件编译成html文件 。<br>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div><div class="line">简写命令：hexo d</div></pre></td></tr></table></figure>
<p>执行这个命令可以将博客部署到git。<br>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="清除-public"><a href="#清除-public" class="headerlink" title="清除 public"></a>清除 public</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure>
<p>当 source 文件夹中的部分资源更改过之后，特别是对文件进行了删除或者路径的改变之后，需要执行这个命令，然后重新编译。 </p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、当执行hexo d部署博客时遇到被hang住没反应的时候，按Crtl + C退出然后执行：hexo clean再执行：hexo d -g即可！</div><div class="line">2、hexo d -g组合命令代表先执行hexo g再执行hexo d</div></pre></td></tr></table></figure>
<h3 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、分段： 两个回车</div><div class="line">2、换行 两个空格 + 回车</div><div class="line">3、标题 # ~ ###### 井号的个数表示几级标题，即Markdown可以表示一级标题到六级标题</div><div class="line">4、引用 &gt;</div><div class="line">5、列表 * ， + ， - ， 1. ，选其中之一，注意后面有个空格</div><div class="line">6、代码区块 四个空格 开头</div><div class="line">7、链接 [文字](链接地址)</div><div class="line">8、图片 ![图片说明](图片地址) ，图片地址可以是本地路径，也可以是网络地址</div><div class="line">9、强调 **文字** ， __文字__ ， _文字_ ， *文字*</div><div class="line">10、代码 ```，``</div></pre></td></tr></table></figure>
<p>More info: <a href="http://www.kancloud.cn/wizardforcel/markdown-simple-world/97373" target="_blank" rel="external">Markdown更多语法</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo Quick Start </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
