<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[MySQL查询优化技术之非SPJ优化]]></title>
      <url>http://riverdba.github.io/2017/04/05/Non-SPJ-Optimization-of-mysql/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>摘要：结合实例探讨mysql查询优化技术中的非SPJ优化<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""><br>SPJ：Select（查询）、Project（投影）、Join（连接）<br>非SPJ：SPJ+[Group By、Order By、Distinct、Limit等]</the></p>
<h3 id="Group-By的优化"><a href="#Group-By的优化" class="headerlink" title="Group By的优化"></a>Group By的优化</h3><p>创建测试数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE t_god (a INT, b INT, c INT, d INT, e INT);</div><div class="line">CREATE INDEX t_god_idx_1 ON t_god (a,b,c);</div><div class="line">CREATE INDEX t_god_idx_2 ON t_god (d);</div></pre></td></tr></table></figure></p>
<p>1、在索引列上执行GROUP BY，支持GROUP BY优化（没有使用“Using file sort”类似的操作进行排序）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 10:44:23&gt;EXPLAIN EXTENDED SELECT a FROM t_god GROUP BY a;</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+----------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra       |</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+----------+-------------+</div><div class="line">|  1 | SIMPLE      | t_god | index | t_god_idx_1   | t_god_idx_1 | 15      | NULL |    1 |   100.00 | Using index |</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+----------+-------------+</div><div class="line">1 row in set, 1 warning (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>2、在索引列上执行ORDERBY，MySQL支持ORDERBY优化：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 10:44:33&gt;EXPLAIN EXTENDED SELECT a FROM t_god ORDER BY a;     </div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+----------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra       |</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+----------+-------------+</div><div class="line">|  1 | SIMPLE      | t_god | index | NULL          | t_god_idx_1 | 15      | NULL |    1 |   100.00 | Using index |</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+----------+-------------+</div><div class="line">1 row in set, 1 warning (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>3、在索引列上执行ORDERBY、GROUPBY，MySQL支持ORDERBY优化也支持GROUPBY优化：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 11:08:54&gt;EXPLAIN EXTENDED SELECT a FROM t_god GROUP BY a ORDER BY a;</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+----------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra       |</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+----------+-------------+</div><div class="line">|  1 | SIMPLE      | t_god | index | t_god_idx_1   | t_god_idx_1 | 15      | NULL |    1 |   100.00 | Using index |</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+----------+-------------+</div><div class="line">1 row in set, 1 warning (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>4、在索引列上执行带有聚集操作的GROUPBY，MySQL支持GROUPBY优化：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 11:10:14&gt;EXPLAIN SELECT a, MIN(b) FROM t_god WHERE c&gt;2 GROUP BY a;</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key         | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | t_god | index | t_god_idx_1   | t_god_idx_1 | 15      | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-------+-------+---------------+-------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<h3 id="Order-By的优化"><a href="#Order-By的优化" class="headerlink" title="Order By的优化"></a>Order By的优化</h3><p>创建测试数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE t_o1 (a1 INT UNIQUE, b1 INT);</div><div class="line">CREATE TABLE t_o2 (a2 INT UNIQUE, b2 INT);</div></pre></td></tr></table></figure></p>
<p>1、在索引列上进行排序操作， MySQL支持利用索引进行排序优化：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 11:13:04&gt;EXPLAIN SELECT a1 FROM t_o1 ORDER BY a1;</div><div class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | t_o1  | index | NULL          | a1   | 5       | NULL |    1 | Using index |</div><div class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>2、排序下推，MySQL不支持。在非索引列上执行连接，然后排序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 11:16:32&gt;EXPLAIN EXTENDED SELECT * FROM t_o1, t_o2 WHERE b1=b2 ORDER BY b1;</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</div><div class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</div><div class="line">|  1 | SIMPLE      | t_o1  | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using temporary; Using filesort                    |</div><div class="line">|  1 | SIMPLE      | t_o2  | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where; Using join buffer (Block Nested Loop) |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line">可以看到执行计划中使用了“Using file sort”临时表操作进行排序</div></pre></td></tr></table></figure></p>
<p>group by、order by对同一个Btree索引的前缀部分可以用到索引进行优化</p>
<h3 id="Distinct的优化"><a href="#Distinct的优化" class="headerlink" title="Distinct的优化"></a>Distinct的优化</h3><p>1、MySQL支持对于DISTINCT消除的优化技术。在主键的a1列上执行DISTINCT是可以去除distinct的，查询执行计划如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 11:36:32&gt;explain select distinct a1 from t1;</div><div class="line">+----+-------------+-------+-------+----------------+--------+---------+------+------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys  | key    | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-------+-------+----------------+--------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | t1    | index | PRIMARY,idx_b1 | idx_b1 | 21      | NULL | 9977 | Using index |</div><div class="line">+----+-------------+-------+-------+----------------+--------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>2、MySQL不支持对于DISTINCT推入的优化技术。<br>a2列是唯一列，又处于反半连接的语义（NOT EXISTS），完全可以把DISTINCT下推到表t_o2中先执行，然后再执行反半连接操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 11:39:21&gt;EXPLAIN EXTENDED SELECT DISTINCT b1 FROM t_o1 WHERE NOT EXISTS (SELECT 1 FROM t_o2 WHERE b1=a2);</div><div class="line">+----+--------------------+-------+------+---------------+------+---------+----------------+------+----------+------------------------------+</div><div class="line">| id | select_type        | table | type | possible_keys | key  | key_len | ref            | rows | filtered | Extra                        |</div><div class="line">+----+--------------------+-------+------+---------------+------+---------+----------------+------+----------+------------------------------+</div><div class="line">|  1 | PRIMARY            | t_o1  | ALL  | NULL          | NULL | NULL    | NULL           |    1 |   100.00 | Using where; Using temporary |</div><div class="line">|  2 | DEPENDENT SUBQUERY | t_o2  | ref  | a2            | a2   | 5       | testdb.t_o1.b1 |    1 |   100.00 | Using index                  |</div><div class="line">+----+--------------------+-------+------+---------------+------+---------+----------------+------+----------+------------------------------+</div><div class="line">2 rows in set, 2 warnings (0.00 sec)</div><div class="line">通过优化器处理后的执行计划可以看出，distinct关键字仍然存在：</div><div class="line">root@testdb 11:39:33&gt;show warnings;</div><div class="line">+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                |</div><div class="line">+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1276 | Field or reference &apos;testdb.t_o1.b1&apos; of SELECT #2 was resolved in SELECT #1                                                                                                                             |</div><div class="line">| Note  | 1003 | /* select#1 */ select distinct `testdb`.`t_o1`.`b1` AS `b1` from `testdb`.`t_o1` where (not(exists(/* select#2 */ select 1 from `testdb`.`t_o2` where (`testdb`.`t_o1`.`b1` = `testdb`.`t_o2`.`a2`)))) |</div><div class="line">+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<h3 id="LIMIT的优化"><a href="#LIMIT的优化" class="headerlink" title="LIMIT的优化"></a>LIMIT的优化</h3><p>1、LIMIT对单表扫描的影响：如果索引扫描可用且花费低于全表扫描，则用索引扫描实现LIMIT（LIMIT取很少量的行，否则优化器更倾向于使用全表扫描）。<br>2、LIMIT对排序的影响：如果LIMIT和ORDERBY子句协同使用，当取到LIMIT设定个数的有序元组数后，后续的排序操作将不再进行。<br>3、LIMIT对去重的影响：如果LIMIT和DISTINCT子句协同使用，当取到LIMIT设定个数的唯一的元组数后，后续的去重操作将不再进行。<br>4、LIMIT受分组的影响：如果LIMIT和GROUPBY子句协同使用，GROUPBY按索引有序计算每个组的总数的过程中，LIMIT操作不必计数直到下一个分组开始计算。<br>5、LIMIT 0：直接返回空结果集。<br>6、MySQL支持对不带HAVING子句的LIMIT进行优化。</p>
<h3 id="SET的优化"><a href="#SET的优化" class="headerlink" title="SET的优化"></a>SET的优化</h3><p>与集合操作相关的优化：ORDER BY子句去除<br>union本身就是无序的合并结果集，在子句中加order by操作是无意义的，因此从下面执行计划中可以看出是没有排序操作的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 01:39:50&gt;explain extended (select * from t1 where b1 &lt; 20 order by b1) union (select * from t2 where b2 &lt; 20 order by b2);</div><div class="line">+----+--------------+------------+-------+---------------+--------+---------+------+------+----------+--------------------------+</div><div class="line">| id | select_type  | table      | type  | possible_keys | key    | key_len | ref  | rows | filtered | Extra                    |</div><div class="line">+----+--------------+------------+-------+---------------+--------+---------+------+------+----------+--------------------------+</div><div class="line">|  1 | PRIMARY      | t1         | range | idx_b1        | idx_b1 | 5       | NULL |   18 |   100.00 | Using where; Using index |</div><div class="line">|  2 | UNION        | t2         | ALL   | NULL          | NULL   | NULL    | NULL | 9999 |   100.00 | Using where              |</div><div class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL          | NULL   | NULL    | NULL | NULL |     NULL | Using temporary          |</div><div class="line">+----+--------------+------------+-------+---------------+--------+---------+------+------+----------+--------------------------+</div><div class="line">3 rows in set, 1 warning (0.01 sec)</div></pre></td></tr></table></figure></p>
<p>如果在order by后面加上limit就无法去除order by子句了。从下面执行计划可以看出存在排序操作（Using filesort）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 01:40:53&gt;explain extended (select * from t1 where b1 &lt; 20 order by b1 limit 5) union (select * from t2 where b2 &lt; 20 order by b2 limit 5);</div><div class="line">+----+--------------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------------+</div><div class="line">| id | select_type  | table      | type  | possible_keys | key    | key_len | ref  | rows | filtered | Extra                       |</div><div class="line">+----+--------------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------------+</div><div class="line">|  1 | PRIMARY      | t1         | range | idx_b1        | idx_b1 | 5       | NULL |   18 |   100.00 | Using where; Using index    |</div><div class="line">|  2 | UNION        | t2         | ALL   | NULL          | NULL   | NULL    | NULL | 9999 |   100.00 | Using where; Using filesort |</div><div class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL          | NULL   | NULL    | NULL | NULL |     NULL | Using temporary             |</div><div class="line">+----+--------------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------------+</div><div class="line">3 rows in set, 1 warning (0.01 sec)</div></pre></td></tr></table></figure></p>
<h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化:"></a>其他优化:</h3><p>1、SELECT DISTINCT a FROM t1 LIMIT 1;<br>2、SELECT DISTICT MAX(a) FROM t1;</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL查询优化技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Innodb的MVCC实现原理]]></title>
      <url>http://riverdba.github.io/2017/04/01/MVCC-theory-study/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>摘要：Innodb的MVCC实现原理学习<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>Multi-Version Concurrency Control（多版本并发控制）是一种并发控制方法，在数据库管理系统中用来提供并发访问数据库的能力，在编程语言中实现事务内存。</p>
<h3 id="MVCC的作用"><a href="#MVCC的作用" class="headerlink" title="MVCC的作用"></a>MVCC的作用</h3><p>读不阻塞写，写不阻塞读。提高数据库的并发访问能力！<br>MVCC只兼容RC和RR两种隔离级别。</p>
<h3 id="数据库多版本读场景"><a href="#数据库多版本读场景" class="headerlink" title="数据库多版本读场景"></a>数据库多版本读场景</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">在session1开启一个事务，查询a表的a1记录：</div><div class="line">root@testdb 01:13:24&gt;set tx_isolation=&apos;read-committed&apos;;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">root@testdb 01:13:43&gt;select @@tx_isolation;</div><div class="line">+----------------+</div><div class="line">| @@tx_isolation |</div><div class="line">+----------------+</div><div class="line">| READ-COMMITTED |</div><div class="line">+----------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">root@testdb 01:13:48&gt;start transaction;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">root@testdb 01:14:16&gt;select * from a where a1=1;</div><div class="line">+------+------+</div><div class="line">| a1   | a2   |</div><div class="line">+------+------+</div><div class="line">|    1 | A1   |</div><div class="line">+------+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">在session2上开启一个事务将A1改为A2，但不提交：</div><div class="line">root@testdb 11:53:18&gt;set tx_isolation=&apos;read-committed&apos;;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">root@testdb 01:13:56&gt;select @@tx_isolation;</div><div class="line">+----------------+</div><div class="line">| @@tx_isolation |</div><div class="line">+----------------+</div><div class="line">| READ-COMMITTED |</div><div class="line">+----------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">root@testdb 01:14:02&gt;start transaction;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">root@testdb 01:14:28&gt;update a set a2=&apos;A2&apos; where a1=1; </div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line">Rows matched: 1  Changed: 1  Warnings: 0</div><div class="line">在session1上查询结果仍然是A1:</div><div class="line">root@testdb 01:14:19&gt;select * from a where a1=1;</div><div class="line">+------+------+</div><div class="line">| a1   | a2   |</div><div class="line">+------+------+</div><div class="line">|    1 | A1   |</div><div class="line">+------+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">在session2上进行提交:</div><div class="line">root@testdb 01:14:39&gt;commit;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">在session1上查询结果变成了A2:</div><div class="line">root@testdb 01:14:44&gt;select * from a where a1=1;</div><div class="line">+------+------+</div><div class="line">| a1   | a2   |</div><div class="line">+------+------+</div><div class="line">|    1 | A2   |</div><div class="line">+------+------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>
<p>可以看到隔离级别是RC的时候，当session2未提交时session1读到的是update前的数据，当session2提交后session1读到的数据是update后的数据。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">session1上开启一个事务，查询a表的a1记录：</div><div class="line">root@testdb 11:51:30&gt;select @@tx_isolation;</div><div class="line">+-----------------+</div><div class="line">| @@tx_isolation  |</div><div class="line">+-----------------+</div><div class="line">| REPEATABLE-READ |</div><div class="line">+-----------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">root@testdb 11:51:54&gt;start transaction;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">root@testdb 11:52:02&gt;select * from a where a1=1;</div><div class="line">+------+------+</div><div class="line">| a1   | a2   |</div><div class="line">+------+------+</div><div class="line">|    1 | A2   |</div><div class="line">+------+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">session2上开启一个事务，将A2改成A1但不提交：</div><div class="line">root@testdb 11:52:32&gt;start transaction;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">root@testdb 11:52:50&gt;update a set a2=&apos;A1&apos; where a1=1; </div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line">Rows matched: 1  Changed: 1  Warnings: 0</div><div class="line">在session1上查到的结果依然为A2：</div><div class="line">root@testdb 11:52:10&gt;select * from a where a1=1;</div><div class="line">+------+------+</div><div class="line">| a1   | a2   |</div><div class="line">+------+------+</div><div class="line">|    1 | A2   |</div><div class="line">+------+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">在session2上进行提交：</div><div class="line">root@testdb 11:53:04&gt;commit;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">在session1上查询到的结果依然为A2：</div><div class="line">root@testdb 11:53:14&gt;select * from a where a1=1;</div><div class="line">+------+------+</div><div class="line">| a1   | a2   |</div><div class="line">+------+------+</div><div class="line">|    1 | A2   |</div><div class="line">+------+------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>可以看出隔离级别是RR的情况下，无论session2是否提交，session1查到的数据都是update前的结果。</p>
<h3 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h3><p>从上面可以看出，在不同的隔离级别下，session1看到的数据是不同的。这由innodb中的MVCC通过undo实现的！<br>事务的隔离性是由锁来实现，而原子性、一致性、持久性通过redo和undo完成。</p>
<h4 id="什么是redo"><a href="#什么是redo" class="headerlink" title="什么是redo"></a>什么是redo</h4><p>redo log用来保证事务的原子性和持久性；redo恢复提交事务修改的页操作；redo是物理日志，记录的是页的物理修改操作；redo存放在redo log文件中；</p>
<h4 id="什么是undo"><a href="#什么是undo" class="headerlink" title="什么是undo"></a>什么是undo</h4><p>undo log用来保证事务的一致性；undo回滚行记录到某个特定版本；undo是逻辑日志，根据每行记录进行记录；undo存放在共享表空间的undo段中；</p>
<h4 id="rollback-segment"><a href="#rollback-segment" class="headerlink" title="rollback segment"></a>rollback segment</h4><p>在innodb中，undo log被划分成多个段，具体某行的undo log就保存在某个段中，成为回滚段。</p>
<h4 id="Innodb中MVCC的实现过程"><a href="#Innodb中MVCC的实现过程" class="headerlink" title="Innodb中MVCC的实现过程"></a>Innodb中MVCC的实现过程</h4><p>1、旧数据存储在UNDO中，再通过DB_ROLL_PTR回溯查找历史版本<br>先看下InnoDB的行存储格式（默认是compact格式）：<br><img src="/2017/04/01/MVCC-theory-study/0.png" alt="图0"><br>可以看到每行数据有个DB_ROLL_PTR（7字节的回滚指针），用于指向该行修改前的上一个历史版本（InnoDB里，会将row data修改前的旧数据存储在UNDO中）。当插入的是一条新数据时，记录上对应的回滚段指针为NULL！如下图：<br><img src="/2017/04/01/MVCC-theory-study/1.png" alt="图1"><br>更新记录时，原记录将被放入到undo表空间中，并通过DB_ROLL_PTR指向该记录。session1查询返回的未修改数据就是从这个UNDO中返回的。MySQL就是根据记录上的回滚段指针及事务ID判断记录是否可见，如果不可见继续按照DB_ROLL_PTR继续回溯查找。如下图：<br><img src="/2017/04/01/MVCC-theory-study/2.png" alt="图2"><br>2、通过read view判断行记录是否可见<br>RR隔离级别下：在每个事务开始的时候，会将当前系统中的所有的活跃事务拷贝到一个列表中(read view)。<br>RC隔离级别下：在事务中的每个语句开始时，会将当前系统中的所有的活跃事务拷贝到一个列表中(read view) 。<br>然后按照以下逻辑判断事务的可见性：<br><img src="/2017/04/01/MVCC-theory-study/3.png" alt="图3"><br>并不是用当前事务ID与表中各个数据行上的事务ID去比较的，而是在每个事务开始的时候，会将当前系统中所有的活跃事务拷贝到read view列表，根据read view最早一个事务ID和最晚的一个事务ID做比较，这样就能确保在当前事务之前没提交的所有事务的变更及后续新启动的事务的变更在当前事务中都是看不到的。当前事务自身的变更是可以看到的。</p>
<p>资料来源：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NzAzMTY4NQ==&amp;mid=2653930052&amp;idx=1&amp;sn=eb4cf71dc838e784af27dff2a1ca8d4b&amp;chksm=bd3b582e8a4cd138536baa9a9b8a831f3f34c7790eed4c6f26ffecf0c332636ad896ed9f8da3&amp;mpshare=1&amp;scene=1&amp;srcid=03317XGPfOUvlUZiJVfCeRXk&amp;pass_ticket=TRE0ji3UrLUUrdtDV4lWf1%2FfQ58FwhCZ8QooTXvY9Dc%3D#rd" target="_blank" rel="external">老叶茶馆微信公共号</a></p>
</the>]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql故障处理记录1]]></title>
      <url>http://riverdba.github.io/2017/03/30/mysql-troubleshooting01/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>摘要：mysql数据库故障处理记录<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="发现故障"><a href="#发现故障" class="headerlink" title="发现故障"></a>发现故障</h3><p>2017-03-29日晚上20点30突然同时收到2条微信告警：（mysql告警:threads_running超过阀值，os告警：cpu usage超过阀值）<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Type: mysql </div><div class="line">Tags: XXX </div><div class="line">Host: 192.168.XXX.XXX:3306 </div><div class="line">Level: critical </div><div class="line">Item: threads_running </div><div class="line">Value: 314 </div><div class="line">Message: too many threads running </div><div class="line">Type: os </div><div class="line">Tags: XXX </div><div class="line">Host: 192.168.XXX.XXX: </div><div class="line">Level: critical </div><div class="line">Item: cpu_idle </div><div class="line">Value: 39% </div><div class="line">Message: too little cpu idle</div></pre></td></tr></table></figure></p>
<h3 id="处理故障"><a href="#处理故障" class="headerlink" title="处理故障"></a>处理故障</h3><p>第一时间登录数据库查看当前运行的SQL：<br><img src="/2017/03/30/mysql-troubleshooting01/1.png" alt="图1"><br>查看慢查询：<br><img src="/2017/03/30/mysql-troubleshooting01/2.png" alt="图2"><br>发现该SQL就是阻塞的根源！<br>查看当前连接数，发现有800多个并发连接卡住，于是第一时间kill掉这些连接以保证业务正常！kill掉连接后数据库连接数下降到正常范围，同时主机CPU也恢复正常！</p>
<h3 id="分析故障"><a href="#分析故障" class="headerlink" title="分析故障"></a>分析故障</h3><p>通过分析这个SQL语句，发现identifying_code字段上是有索引的，这个where条件匹配到的数据存在大量重复（最多的一个identifying_code有十几W行）：<br><img src="/2017/03/30/mysql-troubleshooting01/3.png" alt="图3"><br>而且这些数据中大部分的delete_flag已经是1了。可见这个SQL每次都是将大部分1改为1，并发量大的时候导致每次都锁很多行最终导致连接阻塞。因此可以优化SQL为如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UPDATE XXX</div><div class="line">    set</div><div class="line">      delete_flag = 1</div><div class="line">    where</div><div class="line">    identifying_code = &apos;1517bfd3f7f4558885a&apos; and delete_flag = 0;</div></pre></td></tr></table></figure></p>
<p>这样每次都只将delete_flag为0的改为1，这个条件过滤后每次符合条件的数据只有1行。就避免了每次update大量数据，减少行锁的发生！</p>
<h3 id="故障总结"><a href="#故障总结" class="headerlink" title="故障总结"></a>故障总结</h3><p>这个属于开发的业务逻辑没考虑完善，同时作为DBA没有结合业务做更细的SQL审核也需要自我检讨。</p>
</the>]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 故障诊断 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解mysql的主从复制]]></title>
      <url>http://riverdba.github.io/2017/03/29/Deep-comprehend-mysql-replication/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>摘要：mysql主从复制原理学习笔记<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h3 id="主从复制的架构"><a href="#主从复制的架构" class="headerlink" title="主从复制的架构"></a>主从复制的架构</h3><p><img src="/2017/03/29/Deep-comprehend-mysql-replication/3.png" alt="图3"></p>
<h3 id="主从复制的过程"><a href="#主从复制的过程" class="headerlink" title="主从复制的过程"></a>主从复制的过程</h3><p>当主库上发生事务提交动作时，会记录到主库的binlog中，然后由主库的dump线程发送日志到从库。从库的IO线程负责接收主库的binlog日志并记录到自己的relay log日志。SQL线程负责读取relay log并将数据写入从库。<br>主库的dump线程：<br><img src="/2017/03/29/Deep-comprehend-mysql-replication/0.png" alt="图0"><br>dump线程时刻的等待binlog的变化，一旦变化就将日志发送给从库。<br>从库的IO线程和SQL线程：<br><img src="/2017/03/29/Deep-comprehend-mysql-replication/1.png" alt="图1"><br>从库的IO线程在时刻等待主库的事件发送过来，如果有的话就接受并写入本地的relay log中。<br>从库的SQL线程在时刻等待relay log的变化，一旦有变化就读取并写入数据库。</p>
<p>在主库上看一个事务：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; show master status \G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">             File: mysql-bin.000952</div><div class="line">         Position: 567035014</div><div class="line">     Binlog_Do_DB: </div><div class="line"> Binlog_Ignore_DB: </div><div class="line">Executed_Gtid_Set: 8ac65959-4cb3-11e5-81af-005056a311e0:1-345390234,</div><div class="line">9bc86bd5-a8a0-11e5-991c-005056a3bf07:4-233053957:233053959-572579981</div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line">ERROR: </div><div class="line">No query specified</div><div class="line"></div><div class="line">mysql&gt; show binlog events in &apos;mysql-bin.000952&apos;;</div><div class="line">| mysql-bin.000952 |    236240 | Query          |       706 |      236317 | BEGIN</div><div class="line">| mysql-bin.000952 |    236317 | Rows_query     |       706 |      236630 | # insert into t_table (task_set_id, user_id, task_set_date,task_terminal,</div><div class="line">      task_set_status, day_tast_id, week_task_id, </div><div class="line">      month_task_id)</div><div class="line">    values (&apos;9edd6ca5ff98443f8981a01dc5eae397&apos;, &apos;37728258&apos;, &apos;2017-03-29&apos;, </div><div class="line">      0,2, &apos;1ecf32416e7711e5ad54005056a3bad5&apos;, &apos;&apos;,</div><div class="line">      &apos;&apos;)                                          </div><div class="line">| mysql-bin.000952 |    236630 | Table_map      |       706 |      236712 | table_id: 82476 (t_db.t_table)  </div><div class="line">| mysql-bin.000952 |    236712 | Write_rows     |       706 |      236839 | table_id: 82476 flags: STMT_END_F              </div><div class="line">| mysql-bin.000952 |    236839 | Xid            |       706 |      236870 | COMMIT /* xid=146158662 */          </div><div class="line">| mysql-bin.000952 |    236870 | Gtid           |       706 |      236918 | SET @@SESSION.GTID_NEXT= &apos;9bc86bd5-a8a0-11e5-991c-005056a3bf07:572102075&apos;</div></pre></td></tr></table></figure></p>
<p>注意该事务COMMIT操作后面的<strong>/* xid=146158662 */</strong> ：这是innodb的内部事务号，用于commit的二阶段提交！<br>单实例mysql（内部XA,需设置innodb_support_xa=on）的commit操作要写2个日志：一个是innodb的redo日志（也就是ib_logfile）是没有归档的，因此会被覆盖掉。另一个是mysql的binlog日志，binlog是不会被覆盖的。<br>开始提交阶段：binlog不提交，redo提交<br>正式提交阶段：binlog提交，如果提交成功，则redo完成！如果提交失败，则redo回滚！</p>
<h3 id="主从复制相关参数"><a href="#主从复制相关参数" class="headerlink" title="主从复制相关参数"></a>主从复制相关参数</h3><p>1、server-id：主从要设置不一样<br>2、read_only：主库设为off，从库设为on<br>3、sql_log_bin：主从都开启<br>4、log_slave_updates：如果要做级联复制(M-S-S)就要开启<br>5、binlog_format：row<br>6、binlog_cache_size：<br>7、max_binlog_size：<br>8、expire_logs_days：binlog保存时间<br>9、binlog-do-db：<br>10、binlog-ignore-db：</p>
<h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><p>半同步复制的作用：可以保证主库将日志先传输到备库，然后再返回给应用事务提交成功。这个功能对网络要求较高，如果要使用的话建议把网络优化好一点，比如机器配置千M网卡且将同一组主从服务器位于同一交换机下。<br>查看源码包中是否支持半同步：<br><img src="/2017/03/29/Deep-comprehend-mysql-replication/2.png" alt="图2"><br>使用方法：主库安装semisync_master.so，从库安装semisync_slave.so然后开启rpl_semi_sync_master_enabled=on即可<br>主库安装：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[root@mongohost2 semisync]# /opt/mysql/bin/mysql</div><div class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</div><div class="line">Your MySQL connection id is 243535</div><div class="line">Server version: 5.6.35-log Source distribution</div><div class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</div><div class="line">Oracle is a registered trademark of Oracle Corporation and/or its</div><div class="line">affiliates. Other names may be trademarks of their respective</div><div class="line">owners.</div><div class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</div><div class="line">mysql&gt; show variables like &apos;%rpl_semi%&apos;;</div><div class="line">Empty set (0.00 sec)</div><div class="line">mysql&gt; install plugin rpl_semi_sync_master soname &apos;semisync_master.so&apos;;</div><div class="line">Query OK, 0 rows affected (0.04 sec)</div><div class="line">mysql&gt; show variables like &apos;%rpl_semi%&apos;;</div><div class="line">+------------------------------------+-------+</div><div class="line">| Variable_name                      | Value |</div><div class="line">+------------------------------------+-------+</div><div class="line">| rpl_semi_sync_master_enabled       | OFF   |</div><div class="line">| rpl_semi_sync_master_timeout       | 10000 |  #默认是10秒，可以自己调整</div><div class="line">| rpl_semi_sync_master_trace_level   | 32    |</div><div class="line">| rpl_semi_sync_master_wait_no_slave | ON    |</div><div class="line">+------------------------------------+-------+</div><div class="line">4 rows in set (0.00 sec)</div><div class="line">mysql&gt; set global rpl_semi_sync_master_enabled=on;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">从库：</div><div class="line">mysql&gt; install plugin rpl_semi_sync_slave soname &apos;semisync_slave.so&apos;;</div><div class="line">Query OK, 0 rows affected (0.04 sec)</div></pre></td></tr></table></figure></p>
<h3 id="主从复制常见问题"><a href="#主从复制常见问题" class="headerlink" title="主从复制常见问题"></a>主从复制常见问题</h3><h4 id="主库挂了，如何判断从库是否同步完成？"><a href="#主库挂了，如何判断从库是否同步完成？" class="headerlink" title="主库挂了，如何判断从库是否同步完成？"></a>主库挂了，如何判断从库是否同步完成？</h4><p>从库执行：show slave status \G;<br>查看IO线程读取到主库的binlog日志文件及位置：<br>              Master_Log_File: mysql-bin.000952<br>          Read_Master_Log_Pos: 637762421<br>查看SQL线程执行的文件及位置：<br>        Relay_Master_Log_File: mysql-bin.000952<br>          Exec_Master_Log_Pos: 637762421<br>比较以上两者是否相等。如果都相等说明同步完成，否则没有完成同步！<br>还可以参考：<br>        Seconds_Behind_Master: 0</p>
<p>如果主库重启了。可以通过show master status查看binlog和位置与从库的binlog文件和位置比较是否一致。</p>
<h4 id="mysql主从库同步错误"><a href="#mysql主从库同步错误" class="headerlink" title="mysql主从库同步错误"></a>mysql主从库同步错误</h4><h5 id="错误号：1062"><a href="#错误号：1062" class="headerlink" title="错误号：1062"></a>错误号：1062</h5><p>主键冲突</p>
<h5 id="错误号：1060"><a href="#错误号：1060" class="headerlink" title="错误号：1060"></a>错误号：1060</h5><p>主从DDL不一致</p>
<h5 id="错误号：1032"><a href="#错误号：1032" class="headerlink" title="错误号：1032"></a>错误号：1032</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1032</div><div class="line">Last_Error: Could not execute Update_rows event on table testdb.table; Can&apos;t find record in &apos;table&apos;, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event&apos;s master log mysql-bin.000252, end_log_pos 441796235</div></pre></td></tr></table></figure>
<p>原因：主从数据不一致<br>解决办法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; set sql_slave_skip_counter=1;</div><div class="line">如果就个别事务可以先跳过事务再手动同步数据。如果数据量大则只能重做备库！</div></pre></td></tr></table></figure></p>
<h5 id="错误号：1756"><a href="#错误号：1756" class="headerlink" title="错误号：1756"></a>错误号：1756</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1756</div><div class="line">Last_Error: ... The slave coordinator and worker threads are stopped, possibly leaving data in inconsistent state. A restart should restore consistency automatically, although using non-transactional storage for data or info tables or DDL queries could lead to problems. In such cases you have to examine your data (see documentation for details).</div></pre></td></tr></table></figure>
<p>原因：不明，可能是BUG，偶尔遇到。<br>解决办法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; stop slave;start slave;</div></pre></td></tr></table></figure></p>
<h5 id="错误号：1837"><a href="#错误号：1837" class="headerlink" title="错误号：1837"></a>错误号：1837</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1837</div><div class="line">Last_Error: Worker 7 failed executing transaction &apos;&apos; at master log mysql-bin.000189, end_log_pos 398170585; Error &apos;When @@SESSION.GTID_NEXT is set to a GTID, you must explicitly set it to a different value after a COMMIT or ROLLBACK. Please check GTID_NEXT variable manual page for detailed explanation. Current @@SESSION.GTID_NEXT is &apos;7d7ebcb4-4cb3-11e5-81ae-005056a35f72:198818971&apos;.&apos; on query. Default database: &apos;testdb&apos;. Query: &apos;INSERT INTO table(unit_id, unit_name, unit_type, book_id, sort) VALUES (&apos;130003002653462007003&apos;, &apos;动：综合表演（火车来了）&apos;, 2, &apos;130003002653462&apos;, &apos;130003002653462007003&apos;)&apos;</div></pre></td></tr></table></figure>
<p>原因：不明，可能是BUG，偶尔遇到。<br>解决办法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; stop slave;start slave;</div><div class="line">如果还不行的话就要重启Mysql实例：service mysqld restart</div></pre></td></tr></table></figure></p>
<h5 id="错误号：1236"><a href="#错误号：1236" class="headerlink" title="错误号：1236"></a>错误号：1236</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_IO_Errno: 1236</div><div class="line">Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: &apos;Client requested master to start replication from position &gt; file size; the first event &apos;mysql-bin.000159&apos; at 647052798, the last event read from &apos;/data/log/mysql/mysql-bin.000159&apos; at 4, the last byte read from &apos;/data/log/mysql/mysql-bin.000159&apos; at 4.&apos;</div></pre></td></tr></table></figure>
<p>解决办法：重新指定开始复制的日志位置</p>
<h5 id="错误号：1594"><a href="#错误号：1594" class="headerlink" title="错误号：1594"></a>错误号：1594</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1594</div><div class="line">Last_Error: Relay log read failure: Could not parse relay log event entry. The possible reasons are: the master&apos;s binary log is corrupted (you can check this by running &apos;mysqlbinlog&apos; on the binary log), the slave&apos;s relay log is corrupted (you can check this by running &apos;mysqlbinlog&apos; on the relay log), a network problem, or a bug in the master&apos;s or slave&apos;s MySQL code. If you want to check the master&apos;s binary log or slave&apos;s relay log, you will be able to know their names by issuing &apos;SHOW SLAVE STATUS&apos; on this slave.</div></pre></td></tr></table></figure>
<h5 id="错误号：1118"><a href="#错误号：1118" class="headerlink" title="错误号：1118"></a>错误号：1118</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1118</div><div class="line">Last_Error: Error &apos;Row size too large (&gt; 8126). Changing some columns to TEXT or BLOB or using ROW_FORMAT=DYNAMIC or ROW_FORMAT=COMPRESSED may help. In current row format, BLOB prefix of 768 bytes is stored inline.&apos; on query. Default database: &apos;testdb&apos;. Query: &apos;update table set content = &apos;&lt;span&gt; &lt;/span&gt; \n&lt;p&gt;\n      &lt;span style=&quot;font-family:宋体;font-size:16px;&quot;&gt;&lt;span&gt;一、创设情境、激发兴趣&lt;/span&gt;&lt;/span&gt; \n&lt;/p&gt;\n&lt;span&gt; &lt;/span&gt;&lt;span style=&quot;font-family:宋体;&quot;&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;1、结合具体生活情境，回顾认识质量单位千克、克、吨，进一步感受&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;千克、&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;克、&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-size:16px;&quot;&gt;吨的实际质量。&lt;/span&gt;&lt;/span&gt; \n&lt;p style=&quot;color:#000000;font-family:&amp;quot;Times New Roman&amp;quot;,serif;font-size:10.5pt;font-style:normal;font-weight:normal;&quot;&gt;\n   &lt;sp</div></pre></td></tr></table></figure>
<h5 id="错误号：1755"><a href="#错误号：1755" class="headerlink" title="错误号：1755"></a>错误号：1755</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Last_Errno: 1755</div><div class="line">Last_Error: Cannot execute the current event group in the parallel mode. Encountered event Update_rows, relay-log name /data/mysql2/log/mysqld-relay-bin.000125, position 354 which prevents execution of this event group in parallel mode. Reason: the event is a part of a group that is unsupported in the parallel execution mode.</div></pre></td></tr></table></figure>
<p>原因：5.6版本开启GTID后，MSS架构级联复制的时候会遇到这个BUG（备机salve线程执行SQL,主键冲突的话会导致自己的binlog异常，此时如果有其他备机以这台备机作为主机，会出现复制异常。）<br>解决办法：slave库注释掉：#slave-parallel-workers=64然后重启mysql</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql查询优化技术之语义优化]]></title>
      <url>http://riverdba.github.io/2017/03/28/Sematic-Optimization-of-mysql/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>摘要：工作中遇到的SQL语义优化案例<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="发现慢SQL"><a href="#发现慢SQL" class="headerlink" title="发现慢SQL"></a>发现慢SQL</h3><p>通过监控慢查询，执行时间在1秒以上的SQL如下：<br><img src="/2017/03/28/Sematic-Optimization-of-mysql/图片1.png" alt="图片1"><br>完整SQL：<br><img src="/2017/03/28/Sematic-Optimization-of-mysql/图片2.png" alt="图片2"><br>查看表结构：<br><img src="/2017/03/28/Sematic-Optimization-of-mysql/图片3.png" alt="图片3"><br>查看执行计划：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">EXPLAIN extended</div><div class="line">SELECT id, content, content_type, receiver_id, TYPE, function_type, function_id,</div><div class="line">read_status, send_time, read_time, STATUS</div><div class="line">FROM</div><div class="line">xxxtable</div><div class="line">WHERE receiver_id = &apos;1667510020&apos;</div><div class="line">AND STATUS = 1</div><div class="line">AND TYPE = 2</div><div class="line">AND send_time &lt; &apos;2017-03-22 08:35:50.553&apos; </div><div class="line">AND DATE_SUB(CURDATE(), INTERVAL 12 MONTH ) &lt;= DATE(send_time) </div><div class="line">ORDER BY send_time DESC LIMIT 1; </div><div class="line">/* select#1 */</div><div class="line">select </div><div class="line">`xxxxdb`.`xxxxtable`.`id` AS `id`,</div><div class="line">`xxxxdb`.`xxxxtable`.`content` AS `content`,</div><div class="line">`xxxxdb`.`xxxxtable`.`content_type` AS `content_type`,</div><div class="line">`xxxxdb`.`xxxxtable`.`receiver_id` AS `receiver_id`,</div><div class="line">`xxxxdb`.`xxxxtable`.`type` AS `TYPE`,</div><div class="line">`xxxxdb`.`xxxxtable`.`function_type` AS `function_type`,</div><div class="line">`xxxxdb`.`xxxxtable`.`function_id` AS `function_id`,</div><div class="line">`xxxxdb`.`xxxxtable`.`read_status` AS `read_status`,</div><div class="line">`xxxxdb`.`xxxxtable`.`send_time` AS `send_time`,</div><div class="line">`xxxxdb`.`xxxxtable`.`read_time` AS `read_time`,</div><div class="line">`xxxxdb`.`xxxxtable`.`status` AS `STATUS` </div><div class="line">from</div><div class="line">`xxxxdb`.`xxxxtable` </div><div class="line">where (</div><div class="line">(</div><div class="line">`xxxxdb`.`xxxxtable`.`type` = 2</div><div class="line">) </div><div class="line">and (</div><div class="line">`xxxxdb`.`xxxxtable`.`status` = 1</div><div class="line">) </div><div class="line">and (</div><div class="line">`xxxxdb`.`xxxxtable`.`receiver_id` = &apos;1667510020&apos;</div><div class="line">) </div><div class="line">and (</div><div class="line">`xxxxdb`.`xxxxtable`.`send_time` &lt; &apos;2017-03-22 08:35:50.553&apos;</div><div class="line">) </div><div class="line">and (</div><div class="line">&lt; cache &gt; ((curdate() - interval 12 month)) &lt;= cast(</div><div class="line">`xxxxdb`.`xxxxtable`.`send_time` as date</div><div class="line">)</div><div class="line">)</div><div class="line">) </div><div class="line">order by `xxxxdb`.`xxxxtable`.`send_time` desc </div><div class="line">limit 1</div></pre></td></tr></table></figure></p>
<h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>从表结构定义上看，已经有receiver_id和send_time的联合索引就没必要单独再需要receiver_id索引了。因此可以先drop掉索引idx_receiverid！</p>
<h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>从SQL语义上看，最关键的是发送时间条件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AND send_time &lt; &apos;2017-03-22 08:35:50.553&apos; </div><div class="line">AND DATE_SUB(CURDATE(), INTERVAL 12 MONTH ) &lt;= DATE(send_time)</div></pre></td></tr></table></figure></p>
<p>初步判断业务需求是要查询发送时间小于当前时间，且发送时间在最近12个月内的数据。<br>Send_time数据库中的时间戳格式是：年月日时分秒毫秒，这里却对send_time字段做了date函数转换，开发者目的是为了和12个月前的年月日格式进行比对。为什么不直接让send_time和12个月前的年月日时分秒毫秒格式进行比对呢？这样不就可以去掉对索引字段做函数了吗。因此，我们可以将这2个条件改写为如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AND send_time &lt; &apos;2017-03-22 08:35:50.553&apos; </div><div class="line">AND send_time &gt;= DATE_SUB(NOW(), INTERVAL 12 MONTH )</div></pre></td></tr></table></figure></p>
<p>优化后的执行计划：<br><img src="/2017/03/28/Sematic-Optimization-of-mysql/图片4.png" alt="图片4"><br>这句SQL在优化前的执行计划中是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">and (</div><div class="line">&lt; cache &gt; ((curdate() - interval 12 month)) &lt;= cast(</div><div class="line">`xxxxdb`.`xxxxtable`.`send_time` as date</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>通过对比可以看到优化后省去了mysql对字段做类型转换的工作，同时可以充分利用该字段的索引。</p>
</the>]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql查询优化技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo's tips]]></title>
      <url>http://riverdba.github.io/2017/03/28/hexo-s-tips/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>摘要：hexo小技巧汇总<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="如何修改新建文章模板"><a href="#如何修改新建文章模板" class="headerlink" title="如何修改新建文章模板"></a>如何修改新建文章模板</h3><p>一般文章都需要添加分类和摘要，我们可以加到模板中。进入到hexo根目录的scaffolds下可以看到三个md文件：draft.md\page.md\post.md<br>在post.md中添加分类和摘要后：<br><img src="/2017/03/28/hexo-s-tips/1.png" alt="图片1"><br>这样新建文章的时候就包含分类和摘要了。</p>
<h3 id="如何在博客中引用本地图片"><a href="#如何在博客中引用本地图片" class="headerlink" title="如何在博客中引用本地图片"></a>如何在博客中引用本地图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">首先修改_config.yml中参数 post_asset_folder:true，这样设置后在新建文章时，Hexo会自动创建一个与文章同名的文件夹用来存放图片</div><div class="line">然后安装插件：npm install https://github.com/CodeFalling/hexo-asset-image --save</div><div class="line">引用图片：将图片放在文章同名的文件夹中，比如图片名称：1.png，在md中书写：![图1](hexo-s-comment/1.png)即可。</div></pre></td></tr></table></figure>
<h3 id="报错日志及解决"><a href="#报错日志及解决" class="headerlink" title="报错日志及解决"></a>报错日志及解决</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1:</div><div class="line">报错原因：根据日志定位到第5行，第1列的内容是：categories:Hexo。分类冒号后面需要加个空格再写内容！</div><div class="line">解决办法：改成categories: Hexo即可！</div></pre></td></tr></table></figure>
</the>]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[实现hexo的评论功能]]></title>
      <url>http://riverdba.github.io/2017/03/27/hexo-s-comment/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文介绍如何在博客中添加评论功能！<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""><br>1、首先需要到<a href="https://disqus.com" target="_blank" rel="external">disqus官网</a>注册账号，然后使用账号登录。<br>2、通过账号登录 disqus后，点击“settings”–&gt;在下拉列表中选择“add disqus to site”如图：<br><img src="/2017/03/27/hexo-s-comment/1.png" alt="图1"><br>3、浏览到该网页最下方选择“get started”如图：<br><img src="/2017/03/27/hexo-s-comment/2.png" alt="图2"><br>4、然后点击“i want to install Disqus on my site”：<br><img src="/2017/03/27/hexo-s-comment/3.png" alt="图3"><br>5、创建站点：<br><img src="/2017/03/27/hexo-s-comment/4.png" alt="图4"><br>6、完成create site后就能看到shortname了：<br><img src="/2017/03/27/hexo-s-comment/5.png" alt="图5"><br>7、选择advanced，在Trusted Domains中添加：github.com,github.io<br><img src="/2017/03/27/hexo-s-comment/6.png" alt="图6"><br>注意：一次只能添加一个域名<br>8、最后将shortname填到hexo主题的配置文件中：D:\src\Git\imdba\themes\yelee_config.yml改成如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">disqus: </div><div class="line">  on: true</div><div class="line">  shortname: xxx</div></pre></td></tr></table></figure></the></p>
<p>重新部署下博客，就可以看到每篇文章后面都有评论功能了。<br>有个前提：要登录disqus账号才可以查看和回复评论！</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> disqus </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql性能调优的关键点]]></title>
      <url>http://riverdba.github.io/2017/03/27/Performance-tuning-key-points-of-mysql/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文记录了一些mysql性能调优相关知识。<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h2 id="服务器参数调优，有哪些关键点？"><a href="#服务器参数调优，有哪些关键点？" class="headerlink" title="服务器参数调优，有哪些关键点？"></a>服务器参数调优，有哪些关键点？</h2><h3 id="操作系统的选择"><a href="#操作系统的选择" class="headerlink" title="操作系统的选择"></a>操作系统的选择</h3><p>建议安装在64bit的linux平台（centos\linux\suse）。</p>
<h3 id="关闭SWAP"><a href="#关闭SWAP" class="headerlink" title="关闭SWAP"></a>关闭SWAP</h3><p>设置vm.swappiness = 10，如果设置为0当内存不足时会导致OOM。</p>
<h3 id="关闭NUMA"><a href="#关闭NUMA" class="headerlink" title="关闭NUMA"></a>关闭NUMA</h3><p>如果是单实例部署，需要关闭NUMA。关闭NUMA有3种方式：BIOS中关闭、OS内核中关闭、启动MYSQL时关闭。</p>
<h3 id="多网卡绑定"><a href="#多网卡绑定" class="headerlink" title="多网卡绑定"></a>多网卡绑定</h3><p>一定要做双网卡绑定。关键网络参数调整：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">net.ipv4.tcp_keepalive_time = 120  #用于减少失效tcp连接占用的资源，加快资源回收的效率</div><div class="line">net.ipv4.tcp_keepalive_intvl = 30  #用于减少失效tcp连接占用的资源，加快资源回收的效率</div><div class="line">net.ipv4.tcp_keepalive_probes = 3  #用于减少失效tcp连接占用的资源，加快资源回收的效率</div><div class="line">net.core.rmem_max = 4194304 #最大socket读buffer（单位：字节数）</div><div class="line">net.core.wmem_max = 4194304 #最大socket写buffer（单位：字节数）</div><div class="line">net.ipv4.tcp_moderate_rcvbuf = 1 #开启recv buffer自动调节机制</div><div class="line">net.ipv4.tcp_wmem = 4096        16384   4194304 #为socket发送缓冲区分配的字节数（依次是最小值、默认值、最大值）</div><div class="line">net.ipv4.tcp_rmem = 4096        87380   4194304 #为socket接受缓冲区分配的字节数（依次是最小值、默认值、最大值）</div></pre></td></tr></table></figure></p>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>建议采用deadline。磁盘调度设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">echo deadline &gt; /sys/block/fioa/queue/schedule</div></pre></td></tr></table></figure></p>
<p>查看设置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[root@mysql_42 ~]# cat /sys/block/sda/queue/scheduler </div><div class="line">noop anticipatory deadline [cfq]</div></pre></td></tr></table></figure></p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>推荐选择xfs\ext4，格式化时记得添加noatime,nobarrier参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[root@mysql_42 ~]# mount</div><div class="line">/dev/sda3 on / type ext4 (rw)</div><div class="line">proc on /proc type proc (rw)</div><div class="line">sysfs on /sys type sysfs (rw)</div><div class="line">devpts on /dev/pts type devpts (rw,gid=5,mode=620)</div><div class="line">tmpfs on /dev/shm type tmpfs (rw)</div><div class="line">/dev/sda1 on /boot type ext4 (rw)</div><div class="line">/dev/sdb on /data type ext4 (rw)</div><div class="line">/dev/sdc on /log type ext4 (rw)</div><div class="line">none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)</div></pre></td></tr></table></figure></p>
<h3 id="调大open-files"><a href="#调大open-files" class="headerlink" title="调大open files"></a>调大open files</h3><p>一定要调大open files，可以通过命令：ulimit -n查看。</p>
<h3 id="修改-etc-hosts绑定IP和主机名。"><a href="#修改-etc-hosts绑定IP和主机名。" class="headerlink" title="修改/etc/hosts绑定IP和主机名。"></a>修改/etc/hosts绑定IP和主机名。</h3><h2 id="MySQL性能调优有哪些关键点-经验？"><a href="#MySQL性能调优有哪些关键点-经验？" class="headerlink" title="MySQL性能调优有哪些关键点/经验？"></a>MySQL性能调优有哪些关键点/经验？</h2><h3 id="实例参数调优"><a href="#实例参数调优" class="headerlink" title="实例参数调优"></a>实例参数调优</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">innodb_buffer_pool_size=物理内存的60%-80%  #总IO能力</div><div class="line">innodb_thread_concurrency=CPU的核数  #线程的并发数</div><div class="line">query_cache_type=0  #禁用结果集缓存，一般通过redis\memcache缓存</div><div class="line">query_cache_size=0  #禁用结果集缓存</div><div class="line">max_user_connections=应用连接池大小X应用服务器的数量 #连接数设置要考虑每个会话占用的内存</div><div class="line">interactive_timeout=8小时 #交互连接空闲超时</div><div class="line">wait_timeout=8小时 #非交互的连接空闲超时</div><div class="line">innodb_io_capacity=20000（SSD盘） #innodb每秒后台进程处理IO操作的数据页（page）上限</div><div class="line">innodb_flush_log_at_trx_commit=1 #每次事务提交都刷盘，可保证数据安全。若设置为0的话是每秒刷盘，和提交没关系，不建议。设置为2的话每次提交会把数据存到操作系统的缓存中，然后定期刷盘。如果操作系统挂掉了数据就丢了。5.6以后该参数没有性能问题了。</div><div class="line">sync_binlog=1#1个提交就把日志从缓存写到日志文件</div><div class="line">innodb_log_file_size=1-2G（SAS盘）；4-8G（SSD盘）#日志文件的大小，若设置太小日志文件会频繁切换产生新文件，影响IO能力。</div><div class="line">innodb_log_files_in_group=4-8 #日志组的数量</div><div class="line">innodb_flush_method=O_DIRECT #刷脏块的方式：直接落盘，避免数据多次被cache</div><div class="line">innodb_max_dirty_pages_pct=50 #innodb buffer cache中的脏块刷到磁盘的比例</div><div class="line">innodb_flush_neighbors=0 #合并相邻页数据为1个IO：SAS建议开启，SSD可以关闭</div><div class="line">transaction-isolation = READ-COMMITTED #隔离级别</div></pre></td></tr></table></figure>
<h3 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h3><p>1、制定SQL编写规范，约束开发人员从项目开始阶段就编写出高效的SQL：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、禁止多于3表的join</div><div class="line">2、不要select *</div><div class="line">3、count(*) 尽量用redis缓存去做</div><div class="line">4、避免多作的排序  比如group by 时不用 排序 order by null</div><div class="line">5、模糊查询前缀不用要%  如 like &apos;ss%&apos;</div><div class="line">6、使用in 代替 or</div><div class="line">7、禁止隐式转换</div><div class="line">8、禁止负向查询 如 not in, != ,not like等</div><div class="line">9、尽量用union all 代替  union  ,union 会排序去重</div><div class="line">10、where尽量早过滤</div><div class="line">11、不做计算 如select id*10.2 from t1 </div><div class="line">12、用id条件过滤数据后再分页where id&gt;10000 limit 10，不要用 limit 10000,10</div></pre></td></tr></table></figure></p>
<p>2、实时监控慢查询，通过分析执行计划优化SQL语句<br>3、合理的进行索引设计<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">覆盖索引</div><div class="line">1、查询谓词都能通过index进行扫描</div><div class="line">2、排序谓词都能利用index的有序性</div><div class="line">3、index包含了查询所需要的所有字段，这样只用索引就不用查表了</div><div class="line">不能使用索引</div><div class="line">1、不要给选择率低的字段建索引（通过索引扫描记录超30%就全表扫描了） 如 性别 男和女 直接查表快走索引更慢</div><div class="line">2、联合索引中，第一个索引不要使用范围查询，第一个查询条件不要是最左索引列</div><div class="line">3、like 查询最左 不要是%开始</div><div class="line">4、两个独立索引，一个用于检索，一个用于排序，（索引不是越多越好，尽量合并）</div><div class="line">5、表关联字段类型不一样（长度不一样）不会走索引</div><div class="line">6、索引字段使用函数</div><div class="line">7、不要使用外键约束</div></pre></td></tr></table></figure></p>
<h3 id="架构调优"><a href="#架构调优" class="headerlink" title="架构调优"></a>架构调优</h3><p>实时监控大表，合理制定拆分方案实施分库分表。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql性能调优技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql查询优化技术之连接消除]]></title>
      <url>http://riverdba.github.io/2017/03/22/join-elimination-technique-of-mysql/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文是关于mysql的连接消除技术：外连接消除、连接消除、嵌套连接消除。<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h3 id="连接消除技术包括三种：外连接消除、连接消除、嵌套连接消除"><a href="#连接消除技术包括三种：外连接消除、连接消除、嵌套连接消除" class="headerlink" title="连接消除技术包括三种：外连接消除、连接消除、嵌套连接消除"></a>连接消除技术包括三种：外连接消除、连接消除、嵌套连接消除</h3><p><font color="#0099ff" size="4" face="微软雅黑">1、外连接消除</font><br>外连接消除就是把外连接变为内连接。之所以要消除外连接，是因为查询优化器在处理外连接操作时所消耗的时间多于内连接，因此消除外连接后可以加快查询速度。同时可以减少不必要的I/O开销，加快算法执行速度。<br>创建测试表并插入数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE t_1 (t_1_id INT UNIQUE, t_1_col_1 INT, t_1_col_2 VARCHAR(10));</div><div class="line">CREATE TABLE t_2 (t_2_id INT UNIQUE, t_2_col_1 INT, t_2_col_2 VARCHAR(10));</div><div class="line">INSERT INTO t_1 VALUES (1, 11, &apos;t_1_1&apos;);   INSERT INTO t_1 VALUES (2, 12, NULL);</div><div class="line">INSERT INTO t_1 VALUES (3, NULL, &apos;t_1_3&apos;); INSERT INTO t_1 VALUES (4, 14, &apos;t_1_4&apos;);</div><div class="line">INSERT INTO t_1 VALUES (5, 15, NULL);      INSERT INTO t_1 VALUES (7, NULL, NULL);</div><div class="line">INSERT INTO t_2 VALUES (1, 11, &apos;t_2_1&apos;);   INSERT INTO t_2 VALUES (2, NULL, &apos;t_2_2&apos;);</div><div class="line">INSERT INTO t_2 VALUES (3, 13, NULL);      INSERT INTO t_2 VALUES (4, 14, &apos;t_2_4&apos;);</div><div class="line">INSERT INTO t_2 VALUES (6, 16, &apos;t_2_6&apos;);   INSERT INTO t_2 VALUES (7, NULL, NULL);</div><div class="line">root@testdb 02:21:55&gt;select * from t_1;</div><div class="line">+--------+-----------+-----------+</div><div class="line">| t_1_id | t_1_col_1 | t_1_col_2 |</div><div class="line">+--------+-----------+-----------+</div><div class="line">|      1 |        11 | t_1_1     |</div><div class="line">|      2 |        12 | NULL      |</div><div class="line">|      3 |      NULL | t_1_3     |</div><div class="line">|      4 |        14 | t_1_4     |</div><div class="line">|      5 |        15 | NULL      |</div><div class="line">|      7 |      NULL | NULL      |</div><div class="line">+--------+-----------+-----------+</div><div class="line">6 rows in set (0.00 sec)</div><div class="line">root@testdb 02:22:08&gt;select * from t_2;</div><div class="line">+--------+-----------+-----------+</div><div class="line">| t_2_id | t_2_col_1 | t_2_col_2 |</div><div class="line">+--------+-----------+-----------+</div><div class="line">|      1 |        11 | t_2_1     |</div><div class="line">|      2 |      NULL | t_2_2     |</div><div class="line">|      3 |        13 | NULL      |</div><div class="line">|      4 |        14 | t_2_4     |</div><div class="line">|      6 |        16 | t_2_6     |</div><div class="line">|      7 |      NULL | NULL      |</div><div class="line">+--------+-----------+-----------+</div><div class="line">6 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>语句一：使用TRUE作为ON的子句，WHERE子句包括连接条件且WHERE条件可以保证从结果中排除外连接右侧（右表）生成的值为NULL的行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 02:48:44&gt;SELECT * FROM t_1 LEFT JOIN t_2 ON true WHERE t_1_id = t_2_id;</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">| t_1_id | t_1_col_1 | t_1_col_2 | t_2_id | t_2_col_1 | t_2_col_2 |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">|      1 |        11 | t_1_1     |      1 |        11 | t_2_1     |</div><div class="line">|      2 |        12 | NULL      |      2 |      NULL | t_2_2     |</div><div class="line">|      3 |      NULL | t_1_3     |      3 |        13 | NULL      |</div><div class="line">|      4 |        14 | t_1_4     |      4 |        14 | t_2_4     |</div><div class="line">|      7 |      NULL | NULL      |      7 |      NULL | NULL      |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">5 rows in set (0.00 sec)</div><div class="line">root@testdb 02:22:11&gt;explain extended SELECT * FROM t_1 LEFT JOIN t_2 ON true WHERE t_1_id = t_2_id;show warnings;</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">| id | select_type | table | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">|  1 | SIMPLE      | t_1   | ALL  | t_1_id        | NULL   | NULL    | NULL              |    6 |   100.00 | NULL  |</div><div class="line">|  1 | SIMPLE      | t_2   | ref  | t_2_id        | t_2_id | 5       | testdb.t_1.t_1_id |    1 |   100.00 | NULL  |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                 |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t_1`.`t_1_id` AS `t_1_id`,`testdb`.`t_1`.`t_1_col_1` AS `t_1_col_1`,`testdb`.`t_1`.`t_1_col_2` AS `t_1_col_2`,`testdb`.`t_2`.`t_2_id` AS `t_2_id`,`testdb`.`t_2`.`t_2_col_1` AS `t_2_col_1`,`testdb`.`t_2`.`t_2_col_2` AS `t_2_col_2` from `testdb`.`t_1` join `testdb`.`t_2` where (`testdb`.`t_2`.`t_2_id` = `testdb`.`t_1`.`t_1_id`) |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">从执行计划看到被优化器处理后的语句由left join优化成了join。</div></pre></td></tr></table></figure></p>
<p>语句二：使用ON子句包括连接条件，并不能保证从结果中排除外连接右侧（右表）生成的值为NULL的行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 02:53:25&gt;SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id;</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">| t_1_id | t_1_col_1 | t_1_col_2 | t_2_id | t_2_col_1 | t_2_col_2 |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">|      1 |        11 | t_1_1     |      1 |        11 | t_2_1     |</div><div class="line">|      2 |        12 | NULL      |      2 |      NULL | t_2_2     |</div><div class="line">|      3 |      NULL | t_1_3     |      3 |        13 | NULL      |</div><div class="line">|      4 |        14 | t_1_4     |      4 |        14 | t_2_4     |</div><div class="line">|      5 |        15 | NULL      |   NULL |      NULL | NULL      |</div><div class="line">|      7 |      NULL | NULL      |      7 |      NULL | NULL      |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">6 rows in set (0.01 sec)</div><div class="line">root@testdb 03:06:26&gt;explain extended SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id;show warnings;</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">| id | select_type | table | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">|  1 | SIMPLE      | t_1   | ALL  | NULL          | NULL   | NULL    | NULL              |    6 |   100.00 | NULL  |</div><div class="line">|  1 | SIMPLE      | t_2   | ref  | t_2_id        | t_2_id | 5       | testdb.t_1.t_1_id |    1 |   100.00 | NULL  |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">+-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                            |</div><div class="line">+-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t_1`.`t_1_id` AS `t_1_id`,`testdb`.`t_1`.`t_1_col_1` AS `t_1_col_1`,`testdb`.`t_1`.`t_1_col_2` AS `t_1_col_2`,`testdb`.`t_2`.`t_2_id` AS `t_2_id`,`testdb`.`t_2`.`t_2_col_1` AS `t_2_col_1`,`testdb`.`t_2`.`t_2_col_2` AS `t_2_col_2` from `testdb`.`t_1` left join `testdb`.`t_2` on((`testdb`.`t_1`.`t_1_id` = `testdb`.`t_2`.`t_2_id`)) where 1 |</div><div class="line">+-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">可以看到这个结果集第5行的右侧结果集存在NULL的情况，其执行计划依然是left join，是没办法优化为join的。</div></pre></td></tr></table></figure></p>
<p>语句三：使用ON和WHERE子句包括连接条件,可以保证从结果中排除外连接右侧（右表）生成的值为NULL的行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:06:42&gt;SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id WHERE t_1_id = t_2_id;</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">| t_1_id | t_1_col_1 | t_1_col_2 | t_2_id | t_2_col_1 | t_2_col_2 |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">|      1 |        11 | t_1_1     |      1 |        11 | t_2_1     |</div><div class="line">|      2 |        12 | NULL      |      2 |      NULL | t_2_2     |</div><div class="line">|      3 |      NULL | t_1_3     |      3 |        13 | NULL      |</div><div class="line">|      4 |        14 | t_1_4     |      4 |        14 | t_2_4     |</div><div class="line">|      7 |      NULL | NULL      |      7 |      NULL | NULL      |</div><div class="line">+--------+-----------+-----------+--------+-----------+-----------+</div><div class="line">5 rows in set (0.00 sec)</div><div class="line"></div><div class="line">root@testdb 03:11:24&gt;explain extended SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id WHERE t_1_id = t_2_id;</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">| id | select_type | table | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">|  1 | SIMPLE      | t_1   | ALL  | t_1_id        | NULL   | NULL    | NULL              |    6 |   100.00 | NULL  |</div><div class="line">|  1 | SIMPLE      | t_2   | ref  | t_2_id        | t_2_id | 5       | testdb.t_1.t_1_id |    1 |   100.00 | NULL  |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">root@testdb 03:11:38&gt;show warnings;</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                 |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t_1`.`t_1_id` AS `t_1_id`,`testdb`.`t_1`.`t_1_col_1` AS `t_1_col_1`,`testdb`.`t_1`.`t_1_col_2` AS `t_1_col_2`,`testdb`.`t_2`.`t_2_id` AS `t_2_id`,`testdb`.`t_2`.`t_2_col_1` AS `t_2_col_1`,`testdb`.`t_2`.`t_2_col_2` AS `t_2_col_2` from `testdb`.`t_1` join `testdb`.`t_2` where (`testdb`.`t_2`.`t_2_id` = `testdb`.`t_1`.`t_1_id`) |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">可以看到语句三同语句一是一样的，被优化器处理后的语句由left join优化成了join。</div></pre></td></tr></table></figure></p>
<p>语句四：当外表的索引列出现在WHERE子句中，可以看到依然是left join无法被优化。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:11:38&gt;EXPLAIN EXTENDED SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id WHERE t_1_id&gt;0;show warnings;</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">| id | select_type | table | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra       |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">|  1 | SIMPLE      | t_1   | ALL  | t_1_id        | NULL   | NULL    | NULL              |    6 |   100.00 | Using where |</div><div class="line">|  1 | SIMPLE      | t_2   | ref  | t_2_id        | t_2_id | 5       | testdb.t_1.t_1_id |    1 |   100.00 | NULL        |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line">注：左向外连接的结果集包括左表(t_1)所有的行，不仅是连接所匹配的行，还包括左表某行在右表中没有匹配的行用NULL表示。</div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                                                        |</div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t_1`.`t_1_id` AS `t_1_id`,`testdb`.`t_1`.`t_1_col_1` AS `t_1_col_1`,`testdb`.`t_1`.`t_1_col_2` AS `t_1_col_2`,`testdb`.`t_2`.`t_2_id` AS `t_2_id`,`testdb`.`t_2`.`t_2_col_1` AS `t_2_col_1`,`testdb`.`t_2`.`t_2_col_2` AS `t_2_col_2` from `testdb`.`t_1` left join `testdb`.`t_2` on((`testdb`.`t_2`.`t_2_id` = `testdb`.`t_1`.`t_1_id`)) where (`testdb`.`t_1`.`t_1_id` &gt; 0) |</div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>语句五：当内表的索引列出现在WHERE子句中，left join可以被优化join。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:21:22&gt;EXPLAIN EXTENDED SELECT * FROM t_1 LEFT JOIN t_2 ON t_1_id = t_2_id WHERE t_2_id&gt;0;show warnings;</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">| id | select_type | table | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra       |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">|  1 | SIMPLE      | t_1   | ALL  | t_1_id        | NULL   | NULL    | NULL              |    6 |   100.00 | Using where |</div><div class="line">|  1 | SIMPLE      | t_2   | ref  | t_2_id        | t_2_id | 5       | testdb.t_1.t_1_id |    1 |   100.00 | NULL        |</div><div class="line">+----+-------------+-------+------+---------------+--------+---------+-------------------+------+----------+-------------+</div><div class="line">2 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                                                                     |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t_1`.`t_1_id` AS `t_1_id`,`testdb`.`t_1`.`t_1_col_1` AS `t_1_col_1`,`testdb`.`t_1`.`t_1_col_2` AS `t_1_col_2`,`testdb`.`t_2`.`t_2_id` AS `t_2_id`,`testdb`.`t_2`.`t_2_col_1` AS `t_2_col_1`,`testdb`.`t_2`.`t_2_col_2` AS `t_2_col_2` from `testdb`.`t_1` join `testdb`.`t_2` where ((`testdb`.`t_2`.`t_2_id` = `testdb`.`t_1`.`t_1_id`) and (`testdb`.`t_1`.`t_1_id` &gt; 0)) |</div><div class="line">+-------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>综上实例可以知道外连接优化的本质：语义上是外连接，但WHER条件使得外连接可以蜕化为内连接</p>
<p><font color="#0099ff" size="4" face="微软雅黑">2、连接消除</font><br>连接消除就是去掉不必要的连接对象，减少连接操作。<br>准备测试数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:44:52&gt;select * from t1 limit 1;</div><div class="line">+----+------+</div><div class="line">| a1 | b1   |</div><div class="line">+----+------+</div><div class="line">|  1 | 1    |</div><div class="line">+----+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">root@testdb 03:45:05&gt;select * from t2 limit 1; </div><div class="line">+----+------+</div><div class="line">| a2 | b2   |</div><div class="line">+----+------+</div><div class="line">|  1 |    1 |</div><div class="line">+----+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">root@testdb 03:45:10&gt;select * from t3 limit 1; </div><div class="line">+----+------+</div><div class="line">| a3 | b3   |</div><div class="line">+----+------+</div><div class="line">|  1 |    1 |</div><div class="line">+----+------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>语句1：唯一键/主键作为连接条件，三表内连接可以去掉中间表（mysql优化器不支持，需人工去掉）<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:47:24&gt;select t1.*,t3.* from t1 join t2 on (a1=a2) join t3 on (a2=a3) limit 1;</div><div class="line">+----+------+----+------+</div><div class="line">| a1 | b1   | a3 | b3   |</div><div class="line">+----+------+----+------+</div><div class="line">|  1 | 1    |  1 |    1 |</div><div class="line">+----+------+----+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">root@testdb 04:04:24&gt;explain extended select t1.*,t3.* from t1 join t2 on (a1=a2) join t3 on (a2=a3) limit 1;show warnings;</div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------+------+----------+-------------+</div><div class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref          | rows | filtered | Extra       |</div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------+------+----------+-------------+</div><div class="line">|  1 | SIMPLE      | t1    | index  | PRIMARY       | idx_b1  | 21      | NULL         | 9977 |   100.00 | Using index |</div><div class="line">|  1 | SIMPLE      | t2    | eq_ref | PRIMARY       | PRIMARY | 4       | testdb.t1.a1 |    1 |   100.00 | Using index |</div><div class="line">|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY | 4       | testdb.t1.a1 |    1 |   100.00 | NULL        |</div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------+------+----------+-------------+</div><div class="line">3 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                            |</div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`t1`.`a1` AS `a1`,`testdb`.`t1`.`b1` AS `b1`,`testdb`.`t3`.`a3` AS `a3`,`testdb`.`t3`.`b3` AS `b3` from `testdb`.`t1` join `testdb`.`t2` join `testdb`.`t3` where ((`testdb`.`t2`.`a2` = `testdb`.`t1`.`a1`) and (`testdb`.`t3`.`a3` = `testdb`.`t1`.`a1`)) limit 1 |</div><div class="line">+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">可以看到这个语句中的t2表仅仅作为连接条件，查询目标列没有t2的列，它属于多余的对象，但是优化器依然去连接它。</div><div class="line">我们实际工作中可以人工去掉t2表，改写为：</div><div class="line">root@testdb 03:47:40&gt;select t1.*,t3.* from t1 join t3 on (a1=a3) limit 1;</div><div class="line">+----+------+----+------+</div><div class="line">| a1 | b1   | a3 | b3   |</div><div class="line">+----+------+----+------+</div><div class="line">|  1 | 1    |  1 |    1 |</div><div class="line">+----+------+----+------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>语句2：可去除的表，除了作为连接对象外，不出现在任何子句中比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 03:48:00&gt;select max(b1) from t1,t2;</div><div class="line">+---------+</div><div class="line">| max(b1) |</div><div class="line">+---------+</div><div class="line">| 9999    |</div><div class="line">+---------+</div><div class="line">1 row in set (2.74 sec)</div><div class="line">可以去掉t2：</div><div class="line">root@testdb 03:54:56&gt;select max(b1) from t1;</div><div class="line">+---------+</div><div class="line">| max(b1) |</div><div class="line">+---------+</div><div class="line">| 9999    |</div><div class="line">+---------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">还有select a1 from t1,t2 group by a1可以改为select a1 from t1 group by a1等类似写法</div></pre></td></tr></table></figure></p>
<p><font color="#0099ff" size="4" face="微软雅黑">3、嵌套连接消除</font><br>连接存在多个层次，用括号标识连接的优先次序。嵌套连接消除，就是消除嵌套的连接层次，把多个层次的连接减少为较少层次的连接，尽量“扁平化”。<br>创建测试表及数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE B (b1 INT, b2 VARCHAR(9));</div><div class="line">CREATE TABLE A (a1 INT, a2 VARCHAR(9));</div><div class="line">CREATE TABLE C (c1 INT, c2 VARCHAR(9));</div><div class="line">INSERT INTO B VALUES(1, &apos;B1&apos;), (NULL, &apos;B2&apos;), (31, &apos;B31&apos;), (32, &apos;B32&apos;), (NULL, &apos;B4&apos;),(5, &apos;B5&apos;), (6, &apos;B6&apos;);</div><div class="line">INSERT INTO A VALUES(1, &apos;A1&apos;), (null, &apos;A2&apos;), (NULL, &apos;A31&apos;), (32, &apos;A32&apos;), (4, &apos;A4&apos;), (5, &apos;A5&apos;), (NULL, &apos;A6&apos;);</div><div class="line">INSERT INTO C VALUES(1, &apos;C1&apos;), (NULL, &apos;C2&apos;), (31, &apos;C31&apos;), (NULL, &apos;C32&apos;), (4, &apos;C4&apos;), (NULL, &apos;C5&apos;),(6, &apos;A6&apos;);</div></pre></td></tr></table></figure></p>
<p>语句示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@testdb 04:17:29&gt;EXPLAIN EXTENDED SELECT * FROM A JOIN (B JOIN C ON B.b1=C.c1) ON A.a1=B.b1 </div><div class="line">    -&gt; WHERE A.a1 &gt; 1;</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</div><div class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</div><div class="line">|  1 | SIMPLE      | A     | ALL  | NULL          | NULL | NULL    | NULL |    7 |   100.00 | Using where                                        |</div><div class="line">|  1 | SIMPLE      | B     | ALL  | NULL          | NULL | NULL    | NULL |    7 |   100.00 | Using where; Using join buffer (Block Nested Loop) |</div><div class="line">|  1 | SIMPLE      | C     | ALL  | NULL          | NULL | NULL    | NULL |    7 |   100.00 | Using where; Using join buffer (Block Nested Loop) |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</div><div class="line">3 rows in set, 1 warning (0.00 sec)</div><div class="line"></div><div class="line">root@testdb 04:18:20&gt;show warnings;</div><div class="line">+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                                                                                                                                                                                                                                                                                                                         |</div><div class="line">+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select `testdb`.`a`.`a1` AS `a1`,`testdb`.`a`.`a2` AS `a2`,`testdb`.`b`.`b1` AS `b1`,`testdb`.`b`.`b2` AS `b2`,`testdb`.`c`.`c1` AS `c1`,`testdb`.`c`.`c2` AS `c2` from `testdb`.`a` join `testdb`.`b` join `testdb`.`c` where ((`testdb`.`b`.`b1` = `testdb`.`a`.`a1`) and (`testdb`.`c`.`c1` = `testdb`.`a`.`a1`) and (`testdb`.`a`.`a1` &gt; 1)) |</div><div class="line">+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line">从该SQL语义上看，是希望先执行B和C连接，然后再和A连接。但是执行计划上看到连接顺序依次是先A和B再和C，说明mysql优化器是支持对嵌套连接的消除的。</div></pre></td></tr></table></figure></p>
<p>针对三种连接技术做个简单的总结：</p>
<ul>
<li>连接消除是去掉被连接的某个对象。</li>
<li>外连接消除是去掉外连接的语义使其变为内连接。</li>
<li>嵌套连接消除是一种连接的语义顺序的变化。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql查询优化技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://riverdba.github.io/2017/03/21/hello-world/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>从这里开始，快速开启博客之旅！<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""><br>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</the></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div><div class="line">简写命令：hexo n <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>新建一篇博文，新建的md文件位于：hexo当前目录/source/_posts中。<br>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo server</div><div class="line">简写命令：hexo s</div></pre></td></tr></table></figure>
<p>这个命令是开启本地hexo服务用的，可以访问<a href="http://localhost:4000/进行本地预览。" target="_blank" rel="external">http://localhost:4000/进行本地预览。</a><br>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div><div class="line">简写命令：hexo g</div></pre></td></tr></table></figure>
<p>一般部署上去的时候都需要编译一下，编译后，会出现一个 public 件夹，将所有的md文件编译成html文件 。<br>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div><div class="line">简写命令：hexo d</div></pre></td></tr></table></figure>
<p>执行这个命令可以将博客部署到git。<br>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="清除-public"><a href="#清除-public" class="headerlink" title="清除 public"></a>清除 public</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure>
<p>当 source 文件夹中的部分资源更改过之后，特别是对文件进行了删除或者路径的改变之后，需要执行这个命令，然后重新编译。 </p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、当执行hexo d部署博客时遇到被hang住没反应的时候，按Crtl + C退出然后执行：hexo clean再执行：hexo d -g即可！</div><div class="line">2、hexo d -g组合命令代表先执行hexo g再执行hexo d</div></pre></td></tr></table></figure>
<h3 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1、分段： 两个回车</div><div class="line">2、换行 两个空格 + 回车</div><div class="line">3、标题 # ~ ###### 井号的个数表示几级标题，即Markdown可以表示一级标题到六级标题</div><div class="line">4、引用 &gt;</div><div class="line">5、列表 * ， + ， - ， 1. ，选其中之一，注意后面有个空格</div><div class="line">6、代码区块 四个空格 开头</div><div class="line">7、链接 [文字](链接地址)</div><div class="line">8、图片 ![图片说明](图片地址) ，图片地址可以是本地路径，也可以是网络地址</div><div class="line">9、强调 **文字** ， __文字__ ， _文字_ ， *文字*</div><div class="line">10、代码 ```，``</div></pre></td></tr></table></figure>
<p>More info: <a href="http://www.kancloud.cn/wizardforcel/markdown-simple-world/97373" target="_blank" rel="external">Markdown更多语法</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo Quick Start </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
